<?xml version="1.0" encoding="UTF-8" ?>
<!-- $Id$ -->
<!--
// Copyright (c) 1996-2006 The Regents of the University of California. All
// Rights Reserved. Permission to use, copy, modify, and distribute this
// software and its documentation without fee, and without a written
// agreement is hereby granted, provided that the above copyright notice
// and this paragraph appear in all copies.  This software program and
// documentation are copyrighted by The Regents of the University of
// California. The software program and documentation are supplied "AS
// IS", without any accompanying services from The Regents. The Regents
// does not warrant that the operation of the program will be
// uninterrupted or error-free. The end-user understands that the program
// was developed for research purposes and is advised not to rely
// exclusively on the program for any reason.  IN NO EVENT SHALL THE
// UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
// SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS,
// ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF
// THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE. THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY
// WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE
// PROVIDED HEREUNDER IS ON AN "AS IS" BASIS, AND THE UNIVERSITY OF
// CALIFORNIA HAS NO OBLIGATIONS TO PROVIDE MAINTENANCE, SUPPORT,
// UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
-->

<section
	xmlns="http://docbook.org/ns/docbook" 
	version="5.0" 
	xml:lang="en"
	xmlns:xi="http://www.w3.org/2001/XInclude"
	xmlns:xlink="http://www.w3.org/1999/xlink"
	xml:id="propertypanels">
  
	<title>Property panels</title>
  
	<indexterm>
		<primary>Property panels</primary>
	</indexterm>

	<para>Purpose - to provide a form view of the diagrams and objects in the model. The contents of the model is modifiable. </para>
	<para>The Property panels will be located in <classname>org.argouml.uml.?</classname>. </para> 
	<para>The Property panels is a View subsystem. See <xref xlink:href="#view_control_subsystems"></xref>. </para> 
	<para>The PropPanels for the diagrams are in <classname>org.argouml.uml.diagram.ui</classname> and the property panels for UML objects are in <classname>org.argouml.uml.ui.<replaceable>UML path</replaceable></classname>. </para>

	<section xml:id="addingapropertypanel">
		<title>Adding the property panel</title>
		
		<para>Property Panels for UML model elements are found as class <filename>PropPanel<replaceable>XXX</replaceable>.java</filename>, where <replaceable>XXX</replaceable> is the UML meta-class. They are in sub-packages of org.argouml.uml.ui corresponding to the <replaceable>XXX</replaceable> UML packages, which in turn correspond to their section in the chapter 2 of the UML 1.3 spec. </para>
		<para>So for our example we create a new class <literal>PropPanelExtend</literal> in package <literal>org.argouml.uml.ui.behavior.use_cases</literal>. </para>
		<para>Any associated classes that do not fall into the UML classification are provided in org.argouml.uml.ui. </para>
		<para>Typically the constructor for the new proppanel class invokes the parent constructor, and then builds the fields required on the property tab. The parent constructor may need an icon. If you need a new icon, a call to <literal>lookupIcon()</literal> should be made (note that this is a utility method of the parent PropPanel class). For our example we had to add <literal>Extend.gif</literal>. </para>
		<para xml:id="iconformat" > You will need to make an icon, in .gif format, 16 X 16 pixels, with the transparent background color set to white. Place this file in the org.argouml.Images directory (it must be named like Name.gif). This icon will automatically be used in the toolbar and in the Navigation pane. </para>
		<para>Finally the property panel must be added to the list of property panels in the <literal>run()</literal> method of the <literal>TabProps</literal> class, with a new call of <literal>panels.put()</literal>. If you don't do this, navigation listeners won't know about it!<!-- Huh? TODO: MVW: is this true?--> </para>
		<para>The content of the property panel is created as a grid with columns (1 column if there are only a few fields, 2 or 3 if there are more). Each row of each column contains a caption (i.e. label) and its corresponding field. </para>
		<para>A caption and its field may be added with one of a small number of utility methods which shield you from the layout stuff: addField() and addSeperator(). </para>
		<para>A button may be added to the toolbar with the utility method addButton(). </para>
		<para>Every field is built from Java Swing components. However these are extended by ArgoUML to help in the provision of action methods for fields in the property tab. Several fields involve lists, and these require in addition list models to compute the members of the list. </para>
		<para>The fields that you might add to a property panel include: </para>
		
		<itemizedlist>
			<listitem>
				<para>Simple editable text. For example the Name field. Supported through the <literal>UMLTextField2</literal> class. </para>
			</listitem>
			<listitem>
				<para>A drop down box (aka combobox) of options that can be selected. Supported by the <literal>UMLComboBox2</literal> class. Used e.g. for the type of a parameter. </para>
			</listitem>
			<listitem>
				<para>A check box. This one does not use a seperate model class, thanks to the simplicity of the represented boolean value. Supported by the <literal>UMLCheckBox2</literal> class. Used e.g. for the concurrency checkbox on a composite state. </para>
			</listitem>
			<listitem>
				<para>A radio button. These always come in a group. Supported by the <literal>UMLRadioButtonPanel</literal> class. Used e.g. for selecting the visibility on the properties panel of a class. </para>
			</listitem>
			<listitem>
				<para>A list. Used e.g. for the Generalizations field on the proppanel of a class. The non-editable list is supported by the <literal>UMLList2</literal> class and its child <literal>UMLLinkedList</literal>. The latter also exists in the form of <literal>UMLMutableLinkedList</literal>, which allows adding, creation and deleting elements by popup menu. Used e.g. for the subvertex list for a composite state. </para>
				<para>The list model is usually provided by a sub-class of <literal>UMLModelElementListModel2</literal>. There is a variant <literal>UMLModelElementOrderedListModel2</literal> intended for ordered links, which adds a few items to the pop-up menu, allowing sorting. This latter model is used e.g. for attributes of a class. </para>
			</listitem>
			<listitem>
				<para>A drop down box of options that can be selected. This one exists in several versions, each having different possibilities. The most simple version is the <literal>UMLComboBox2</literal>. </para>
				<para>The <literal>UMLEditableComboBox</literal> allows editing the selected item. </para>
				<para>The <literal>UMLSearchableComboBox</literal> allows editing the selected item. See e.g. the Operation combobox on the callevent properties panel. </para>
				<para>Then there is a variant with a seperate button for navigation to the property panel for the currently selected item. This is supported by the<literal>UMLComboBoxNavigator</literal> class. Used e.g. for the stereotype field. </para>
			</listitem>
			<listitem>
				<para>An editable multiline text area. Supported by the <literal>UMLTextArea2</literal> class. Used e.g. for the text field of a UML Comment. </para>
			</listitem>
		</itemizedlist>
		
		<para>Examples of these fields in more detail follow below.</para>
		
		<section>
			<title>Adding a simple list field</title>
			
			<para>For example we need to add a field to the use case property panel for the extends relationships that derive from this use case. </para>
			<para>This field consists of a label and a scrollable pane (<literal>JScrollPane</literal>) containing the list (<literal>JList</literal>), which may be empty, or contain extend relationships from this use case. </para>
			<para>Rather than a straight <literal>JList</literal>, we use its child, <literal>UMLLinkedList</literal>, which adds several features to the standard JList specifically for ArgoUML's properties panels. </para>
			<para>The constructor for <literal>UMLLinkedList</literal> requires two arguments, a list model and a flag to indicate whether to show an icon. </para>
			<para>The list model should be a subclass of <literal>UMLModelElementListModel2</literal>, a subclass of the Swing <literal>DefaultListModel</literal> which implements <literal>AbstractListModel</literal>. The <literal>UMLModelElementListModel2</literal> implements two interfaces: one that listens to target changes, and one that listens to UML model changes. </para>
			
			<section>
				<title>The list model</title>
				
				<para>In our example we create <literal>UMLUseCaseExtendListModel</literal>. Its constructor takes no arguments. However, we need to provide the parent class with a Model subsystem event name by invoking the constructor of the parent class, with the event name as parameter. </para>
				<para>A string naming an Model subsystem event that should force a refresh of the list model. A null value will cause all events to trigger a refresh. The name of the event is the same as the name of the associated attribute or association end from the UML 1.4 metamodel. </para>
				<para>This list model should then be provided with a number of methods. The following are mandatory, since they are declared abstract in the parent. </para>
				
				<variablelist>
					<varlistentry>
						<term>
							<literal>protected void buildModelList()</literal>
						</term>
						<listitem>
							<para>(Re)Builds the list of elements. Called from targetChanged every time the target of the proppanel is changed. </para>
						</listitem>
					</varlistentry>
					<varlistentry>
						<term>
							<literal>protected boolean isValidElement(Object/*MBase*/ o)</literal>
						</term>
						<listitem>
							<para>Returns true if the given element is valid, i.e. it may be added to the list of elements. This function is called for many UML elements, to determine if it fits in the list. Remark: The indication /*MBase*/ is a remainder from the time that ArgoUML included direct references to the NSUML model all over the code. Now it is a practical reminder of what we are dealing with. </para>
						</listitem>
					</varlistentry>
				</variablelist>
				
				<warning>
					<para>The following description is old and the property panels have undergone some fundamental changes since it was written. It would be good if someone that knows how it works now could write a description on how it works now. </para>
				</warning>
				
				<para>The following are sometimes provided as an override of the parent, although for many uses the default is fine. </para>
				
				<variablelist>
					<varlistentry>
						<term>
							<literal>public void open(int index)</literal>
						</term>
						<listitem>
							<para>Perform the action associated with the <quote>open</quote> pop-up menu on the element at the given index. The default provided in the parent just navigates to that element. </para>
						</listitem>
					</varlistentry>
					
					<varlistentry>
						<term>
							<literal>public boolean buildPopup(JPopupMenu popup, int index)</literal>
						</term>
						<listitem>
							<para>Build a pop-up menu for the list and return whether it should be displayed. Any actions will be associated with the item at the given index in the list. This is built using <literal>UMLListMenuItem</literal>, which can record the index, rather than plain <literal>JListItem</literal>. The default provides open, add, delete, move up and move down, with add disabled if there are already as many elements as the upper bound (if any) for the list, open and delete disabled if there are no elements and move up and move down disabled if they cannot be invoked on the given element. The default implementation always returns true. </para>
						</listitem>
					</varlistentry>
				</variablelist>
				
				<para>The following should be declared as needed to support particular pop-up functions. </para>
				
				<variablelist>
					<varlistentry>
						<term>
							<literal>public void add(int index)</literal>
						</term>
						<listitem>
							<para>Perform the actions associated with the <quote>add</quote> pop-up menu on the element at the given index. There is no default provided, so this must be given if the <quote>add</quote> operation is supported. The <literal>addAtUtil()</literal> method (see below) may prove helpful. </para>
							<para>In this routine you may create a new Model subsytem entity. The best way to do this is using a buildXXX method from the appropriate factory so that the appropriate initialization gets done, but you can also use a createXXX method and set it up (don't forget e.g namespace etc) yourself. Remember also to change anything that references the newly created entity. </para>
							<warning>
								<para>NOTE: The following was written regarding NSUML. It may be generally true for the Model subsystem, but this hasn't been verified. </para>
								<para>NSUML routines generally set up the <quote>other</quote> end of a relationship automatically if you set up one end. If you try to do both (on a NxM relationship) you will probably end up doing it twice. If you do encounter this, the rule of thumb is to explicitly set the ordered end (if you do it the other way round, NSUML will assume you mean the "other" end to be at the end of its ordered list). </para>
							</warning>
						</listitem>
					</varlistentry>
					<varlistentry>
						<term>
							<literal>public void delete(int index)</literal>
						</term>
						<listitem>
							<para>Perform the actions associated with the <quote>delete</quote> pop-up menu on the element at the given index. There is no default provided, so this must be given if the <quote>delete</quote> operation is supported. </para>
						</listitem>
					</varlistentry>
					<varlistentry>
						<term>
							<literal>public void moveUp(int index)</literal>
						</term>
						<listitem>
							<para>Perform the actions associated with the <quote>move up</quote> pop-up menu on the element at the given index. There is no default provided, so this must be given if the <quote>move up</quote> operation is supported. </para>
						</listitem>
					</varlistentry>
					<varlistentry>
						<term>
							<literal>public void moveDown(int index)</literal>
						</term>
						<listitem>
							<para>Perform the actions associated with the <quote>move down</quote> pop-up menu on the element at the given index. There is no default provided, so this must be given if the <quote>move down</quote> operation is supported. </para>
						</listitem>
					</varlistentry>
				</variablelist>
				
				<para>The following normally use the default method, but may be declared to override methods in the parent </para>
				
				<variablelist>
					<varlistentry>
						<term>
							<literal>public void resetSize()</literal>
						</term>
						<listitem>
							<para>Called when an external event may have changed the size of the list. The default just sets a flag, which will ensure recalcModelElementSize (see above) is invoked as needed. </para>
						</listitem>
					</varlistentry>
					<varlistentry>
						<term>
							<literal>public Object formatElement(MModelElement element)</literal>
						</term>
						<listitem>
							<para>Return an object (invariably a String) that represents an element. The default provided in the parent defers this to the container, which in turn defers it to the current profile. This is usually perfectly satisfactory. </para>
						</listitem>
					</varlistentry>
					<varlistentry>
						<term>
							<literal>public void targetChanged()</literal>
						</term>
						<listitem>
							<para>Called when the number of elements in the displayed list (including <quote>none</quote>) may have changed. Default invokes the necessary Swing operations to advise of a change in list size. </para>
						</listitem>
					</varlistentry>
					<varlistentry>
						<term>
							<literal>public void targetReasserted()</literal>
						</term>
						<listitem>
							<para>Called when the navigation history has been changed (and navigation buttons may need changing). Not clear why anything is needed, but default recomputes the list size, and invokes the necessary Swing operations. </para>
						</listitem>
					</varlistentry>
					<varlistentry>
						<term>
							<literal>public void roleAdded(final MElementEvent event)</literal>
						</term>
						<listitem>
							<!-- TODO: -->
							<warning>
								<para>This describes the old event interface. It needs to be updated.</para>
							</warning>
							<para>part of the NSUML EventListener interface. Called when an add event happens, i.e. some Model subsystem object has been added. The default provided looks to see if the event is the role name we declared, or we are listening to all events, and if so looks to see if it relates to an element in our list. If so Swing is notified that the element has been added. </para>
						</listitem>
					</varlistentry>
					<varlistentry>
						<term>
							<literal>public void roleRemoved(final MElementEvent event)</literal>
						</term>
						<listitem>
							<!-- TODO: -->
							<warning>
								<para>This describes the old event interface. It needs to be updated.</para>
							</warning>
							<para>part of the NSUML EventListener interface. Called when a remove event happens, i.e. some Model subsystem object has been removed. The default provided looks to see if the event is the role name we declared, or we are listening to all events, and if so looks to see if it relates to an element in our list. If so Swing is notified that the element has been removed. </para>
						</listitem>
					</varlistentry>
					<varlistentry>
						<term>
							<literal>public void recovered(final MElementEvent p1)</literal>
						</term>
						<term>
							<literal>public void listRoleItemSet(final MElementEvent p1)</literal>
						</term>
						<term>
							<literal>public void removed(final MElementEvent p1)</literal>
						</term>
						<term>
							<literal>public void propertySet(final MElementEvent p1)</literal>
						</term>
						<listitem>
							<!-- TODO: -->
							<warning>
								<para>This describes the old event interface. It needs to be updated.</para>
							</warning>
							<para>these are all required as part of the NSUML EventListener interface, which is not well documented. In each case the default implementation recomputes the size, and advises Swing that the entire list has changed. Needs more investigation. </para>
						</listitem>
					</varlistentry>
					<varlistentry>
						<term>
							<literal>public void navigateTo(MModelElement modelElement)</literal>
						</term>
						<listitem>
							<para>a request to navigate to the specified object as part of the NavigationListener interface. The default in the parent just invokes navigateTo() on the container (ultimately PropPanel). </para>
						</listitem>
					</varlistentry>
				</variablelist>
				
				<para>The following utility routines are also provided in the parent. They are not normally overridden. </para>
				
				<variablelist>
					<varlistentry>
						<term>
							<literal>public int getUpperBound()</literal>
						</term>
						<listitem>
							<para>get any upper bound (-1 is used if there is none). </para>
						</listitem>
					</varlistentry>
					<varlistentry>
						<term>
							<literal>public void setUpperBound(int newBound)</literal>
						</term>
						<listitem>
							<para>set the upper bound (-1 is used if there is none). </para>
						</listitem>
					</varlistentry>
					<varlistentry>
						<term>
							<literal>public final String getProperty()</literal>
						</term>
						<listitem>
							<para>returns the Model subsystem event name being monitored (null if all are being monitored). </para>
						</listitem>
					</varlistentry>
					<varlistentry>
						<term>
							<literal>protected final int getModelElementSize()</literal>
						</term>
						<listitem>
							<para>returns the number of elements in the list. Invokes <literal>recalcModelElementSize()</literal> (see above) if necessary. </para>
						</listitem>
					</varlistentry>
					<varlistentry>
						<term>
							<literal>final Object getTarget()</literal>
						</term>
						<listitem>
							<para>returns the Model subsystem object associated with the container (some child of <literal>PropPanel</literal> usually) that holds this list model. </para>
						</listitem>
					</varlistentry>
					<varlistentry>
						<term>
							<literal>final UMLUserInterfaceContainer getContainer()</literal>
						</term>
						<listitem>
							<para>returns the the container (some child of <literal>PropPanel</literal> usually) that holds this list model. </para>
						</listitem>
					</varlistentry>
					<varlistentry>
						<term>
							<literal>public int getSize()</literal>
						</term>
						<listitem>
							<para>returns the size of the list. Including if there are no elements in the model, but the list has a default text when empty. </para>
						</listitem>
					</varlistentry>
					<varlistentry>
						<term>
							<literal>public Object getElementAt(int index)</literal>
						</term>
						<listitem>
							<para>returns the element at the given index in the list. </para>
						</listitem>
					</varlistentry>
					<varlistentry>
						<term>
							<literal>static protected Collection addAtUtil(Collection oldCollection, MModelElement newItem, int index)</literal>
						</term>
						<listitem>
							<para>helps in writing the <quote>add</quote> function. newItem is added at the specified index in the given oldCollection. </para>
						</listitem>
					</varlistentry>
					<varlistentry>
						<term>
							<literal>static protected java.util.List moveUpUtil(Collection oldCollection, int index)</literal>
						</term>
						<listitem>
							<para>helps in writing the <quote>move up</quote> function. Swaps the elements at offsets index and index-1. Not clear why it doesn't return a Collection. </para>
						</listitem>
					</varlistentry>
					<varlistentry>
						<term>
							<literal>static protected java.util.List moveDownUtil(Collection oldCollection, int index)</literal>
						</term>
						<listitem>
							<para>helps in writing the <quote>move down</quote> function. Swaps the elements at offsets index and index-1. Not clear why it doesn't return a Collection. </para>
						</listitem>
					</varlistentry>
					<varlistentry>
						<term>
							<literal>static protected MModelElement elementAtUtil(Collection collection, int index, Class requiredClass)</literal>
						</term>
						<listitem>
							<para>helps in writing the <literal>getElementAt()</literal>. Finds the element at a specific index. The last argument is ignored! </para>
						</listitem>
					</varlistentry>
				</variablelist>
			</section>
		</section>
		
		<section>
			<title>Building the field</title>
			<para>By convention the background of the list is set to the same as the background of the PropPanel and the foreground to Color.blue. </para>
			<para>The list is then added to a <literal>JScrollPane</literal>. Although ArgoUML has historically not used scrollbars (<literal>JScrollPane.VERTICAL_SCROLLBAR_NEVER</literal> and <literal>JScrollPane.HORIZONTAL_SCROLLBAR_NEVER</literal>), it is more helpful to permit at least a vertical scrollbar where needed (<literal>JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED</literal> and <literal>JScrollPane.HORIZONTAL_SCROLLBAR_AS_NEEDED</literal>). </para>
			<para>Finally the inherited method <literal>addCaption()</literal> is used to add the label for the field and <literal>addField()</literal> to add the associated scroll pane. </para>
			<para>The second argument of each of these identifies the index of the caption/field pair in the vertical column of the grid for this property panel. The third argument identifies the column index. The final argument is a vertical weighting to expand the field if there is room in the property tab. This is usually set to the same non-zero value for all fields and corresponding captions that can have multiple entries, so they expand equally. If none of the fields should expand, the caption only of the last field in each column should be given a non-zero value. </para>
		</section>
		
		<section>
			<title>Adding Property Tab Tool-bar Buttons</title>
			
			<para>These are added by creating new instances of <literal>PropPanelButton</literal> (you don't need to assign them to anything - just creating will do). This has six arguments. </para>
			
			<itemizedlist>
				<listitem>
					<para>The container, i.e this property panel (usually just use <literal>this</literal>). </para>
				</listitem>
				<listitem>
					<para>The panel for the buttons. Use <literal>buttonPanel</literal> which is inherited from <literal>PropPanel</literal>. </para>
				</listitem>
				<listitem>
					<para>The icon. Lots of these are already defined in <literal>PropPanel</literal>. </para>
				</listitem>
				<listitem>
					<para>The advisory text for the button. Use <literal>localize(string)</literal> to ensure international portability. </para>
				</listitem>
				<listitem>
					<para>The name of the method to invoke when this button is used. Some of the standard ones (e.g for navigation) are provided, but you will need to write any specials. </para>
				</listitem>
				<listitem>
					<para>The name of the method (if any) to invoke to see if this button should be enabled. Use <literal>null</literal> if the button should always be enabled. </para>
				</listitem>
			</itemizedlist>
			<para>In our example, the extend property panel has a <quote>add extension point</quote> button, with a method <literal>newExtensionPoint</literal> that we provide to create a new use case. </para>
		</section>
		<section>
			<title>Support for stereotypes</title>
			
			<para>The PropPanel should override the following (note the spelling of the method name). </para>
			<para>
				<literal>protected boolean isAcceptibleBaseMetaClass(String baseClass)</literal>. Returns <literal>true</literal> if the given base class is a class of the target in the <literal>PropPanel</literal>. </para>
			<para>This is used to determine what stereotypes may be shown for this property panel. </para>
		</section>
		
		<section>
			<title>Other sorts of fields</title>
			
			<para>Another sort of field that may be useful is the ComboBox. This is useful to allow users to select from a pre-defined list of alongside a navigation arrow to go to the selected entry. </para>
			<para>For example this is used to provide drop-down lists for the base and extension use cases of an Extend relationship in PropPanelExtend. </para>
			<para>The model behind the drop down is created by using <literal>UMLComboBoxModel</literal>: <literal>UMLComboBoxModel(container, predicate, event, getter, setter, allowVoid, baseClass, useModel)</literal>. </para>
			<para>The container is the <literal>PropPanel</literal> where we are setting up this ComboBox, the predicate is the name of a public method in that PropPanel that, given a model element, determines if it should be in the drop down, the event is the Model subsystem event name we are looking for (see earlier for the list), <literal>getter</literal> is the name of a public method in the PropPanel that yields the current entry in the combo Box (of type <literal>baseClass</literal>), <literal>setter</literal> (with a single argument of type <literal>baseClass</literal>) sets that entry, <literal>allowVoid</literal> if <literal>true</literal> will allow an empty entry for the box, <literal>baseClass</literal> is the UML metaclass from which all entries must descend, <literal>useModel</literal> is <literal>true</literal> to consider all the elements in the standard profile model for inclusion (so the Java types, standard stereotypes etc.). </para>
			<para>For our <literal>PropPanelExtend</literal>, we provide a predicate routine the call for the <quote>base</quote> field is: </para>
			<para><literal>UMLComboBoxModel(this, "isAcceptableUseCase", "base", "getBase", "setBase", true, MUseCase.class, true);</literal> </para>
			<para>and we define the methods <literal>isAcceptableUseCase</literal>, <literal>getBase</literal> and <literal>setBase</literal> in <literal>PropPanelExtend</literal>. </para>
		</section>
		
		<section>
			<title>How UMLTextField works</title>
			
			<para>This information is provided by Jaap Branderhorst (September 2002). </para>
			<para>
				<classname>UMLTextField</classname> implements several kinds of event listeners: <itemizedlist>
					<listitem>
						<para>
							<interfacename>MMelementListener</interfacename>
						</para>
					</listitem>
					<listitem>
						<para>
							<interfacename>DocumentListener</interfacename>
						</para>
					</listitem>
					<listitem>
						<para>
							<interfacename>FocusListener</interfacename>
						</para>
					</listitem>
				</itemizedlist> Furthermore it is a <classname>UMLUserInterfaceComponent</classname>. </para>
			<para>Since it is an <classname>UMLUserInterfaceComponent</classname> it must implement <methodname>targetChanged</methodname> and <methodname>targetReasserted</methodname>. <methodname>TargetChanged</methodname> is called every time the <classname>UMLTextField</classname> is selected. <methodname>targetReasserted</methodname> is of no interest for <classname>UMLTextField</classname>. It plays a role in keeping history but since history is not really implemented at the moment in ArgoUML it is of no interest. <methodname>targetChanged</methodname> does two things: 
				<itemizedlist>
					<listitem>
						<para>It calls the <methodname>targetChanged</methodname> method of the <classname>UMLTextProperty</classname> this <classname>UMLTextfield</classname> is showing. </para>
					</listitem>
					<listitem>
						<para>It calls the <methodname>update</methodname> method. The <methodname>update</methodname> method is described further on. </para>
					</listitem>
				</itemizedlist>
			</para>
			
			<para>Besides <classname>UMLUserInterfaceComponent</classname> there are several other interfaces of interest. One of them is <interfacename>MMElementListener</interfacename>. </para>
			<para>Every time a <interfacename>MModelElement</interfacename> is changed this will fire an <classname>MEvent</classname> to <classname>UMLChangeDispatch</classname>. <classname>UMLChangeDispatch</classname> will dispatch these events to all containers implementing <interfacename>UMLUserInterfaceComponents</interfacename> interested in this event, including <classname>UMLTextField</classname>. It will also dispatch the event to all children of an interested container implementing <interfacename>UMLUserInterfaceComponent</interfacename>. By this it is only necessary to register a <classname>PropPanel</classname> which holds an <classname>UMLTextField</classname> at <classname>UMLChangeDispatch</classname> to dispatch the event to the <classname>UMLTextField</classname> too. <interfacename>MMelementListener</interfacename> knows several methods of which only one is of interest to <classname>UMLTextField</classname>s: 
				<itemizedlist>
					<listitem>
						<para>propertySet</para>
						<para>Called every time a property in a <classname>MModelElement</classname> is set. This method calls <methodname>update</methodname> too if the <classname>UMLTextProperty</classname> really is affected. </para>
					</listitem>
				</itemizedlist>
			</para>
			
			<para>Furthermore <classname>UMLTextField</classname> implements <interfacename>DocumentListener</interfacename>. This is very typical for <classname>UMLTextField</classname>. At the moment it is not possible to change the style of the text in the <classname>UMLTextField</classname>. Therefore the method <methodname>changedUpdate</methodname> does not have a body. This method is only called when a <classname>DocumentEvent</classname> occurs that changes the style/layout of the text. The methods <methodname>insertUpdate</methodname> and <methodname>removeUpdate</methodname> are respectively called when a character is added to the document <classname>UMLTextField</classname> contains or removed. Since both methods are called when there is true user input and when the contents of the document are changed programmatically, the methods distinguish between them. <methodname>InsertUpdate</methodname> and <methodname>removeUpdate</methodname> are both handled via the protected method <methodname>handleEvent</methodname>. <methodname>HandleEvent</methodname> updates the property in <classname>UMLTextProperty</classname> if it is really changed. If the update comes via user input, it is checked if it is valid input. If it is not, a <classname>JOptionPane</classname> is shown with ' a warning and the change is not committed into the model. If it is not via user input, the input is not checked and the property is set. If the property is set, the update method is called. </para>
			<para>The implementation of <interfacename>FocusListener</interfacename> makes sure that the checking of user input only happens when focus is lost. Otherwise, it would not be possible to enter 'intermediate' values that are not legal. For instance, say the value class is not legal. Without the implementation of <interfacename>FocusListener</interfacename>, it would not be possible to enter class diagram since handleEvent would pop-up a warning message box. </para>
			<para>The method <methodname>update</methodname> updates both the actual <classname>JTextfield</classname> as the diagram as soon as some property is set. The updating of the diagram is done by calling the <methodname>damage</methodname> method of the figs that represent the property on the diagram. </para>
		</section>
	</section>

</section>

<!-- Local stuff for Emacs - please do not delete

Local Variables:
mode: xml
sgml-doctype: "cookbook.xml"
sgml-parent-document: ("cookbook.xml" "sect1" nil)
sgml-validate-command: "nsgmls -wxml -sv ../docbook-setup/xml.dcl \
  cookbook.xml"
indent-tabs-mode: nil
End:

-->
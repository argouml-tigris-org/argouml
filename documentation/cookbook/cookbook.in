<?xml version="1.0" encoding="ISO-8859-1"?>
<!-- $Id$ -->

<!DOCTYPE book SYSTEM "../docbook-setup/docbookx/docbookx.dtd" [
<!ENTITY building SYSTEM "building.xml">
<!ENTITY requirements SYSTEM "require.xml">
<!ENTITY cvs SYSTEM "cvs.xml">
<!ENTITY standards SYSTEM "standard.xml">
<!ENTITY processes SYSTEM "process.xml">

<!ENTITY componentmodel SYSTEM "compmdl.xml">
<!ENTITY componentcritics SYSTEM "compcrit.xml">
<!ENTITY componentdiagrams SYSTEM "compdiag.xml">
<!ENTITY componentpropertypanels SYSTEM "compprpp.xml">
<!ENTITY componentinternationalization SYSTEM "compi18n.xml">
<!ENTITY cookbookmodules SYSTEM "cookbook_modules.xml">
<!ENTITY cookbooklogging SYSTEM "cookbook_logging.xml">

<!ENTITY argoversion    "@VERSION@">

]>

<!-- THIS IS THE ARGO/UML DEVELOPER COOKBOOK 
     - PLEASE FEEL FREE TO ADD TO THE CONTENT AND INSERT YOUR 
     NAME IN THE AUTHOR GROUP.
     - IMAGES SHOULD BE LOCATED IN THE GENERAL IMAGES SECTION OF THE 
     DOCUMENTATION MODULE UNDER THE DIRECTORY COOKBOOK
     - PLEASE VERIFY THAT YOUR CHANGES COMPILE CORRECTLY BEFORE COMMITING THEM
-->

<book>
     <bookinfo>
         <date>2001-11-10
         </date>
         <title>Cookbook for Developers of ArgoUML</title>
         <subtitle>An introduction to ArgoUML Programming</subtitle>
    <abstract>
      <para>
The purpose of this Cookbook is to help in coordinating 
and documenting the development of ArgoUML.
</para>
      <para>
This version of the cookbook is loosely connected to the version
&argoversion; of ArgoUML.
</para>
    </abstract>
         <authorgroup>
             <author>
                 <firstname>Markus</firstname>
                 <surname>Klink</surname>
             </author>
             <author>
                 <firstname>Linus</firstname>
                 <surname>Tolke</surname>
             </author>
         </authorgroup>
         <legalnotice>
             <para>
 Copyright (c) 1996-2003 The Regents of the University of California. All
 Rights Reserved. Permission to use, copy, modify, and distribute this
 software and its documentation without fee, and without a written
 agreement is hereby granted, provided that the above copyright notice
 and this paragraph appear in all copies.  This software program and
 documentation are copyrighted by The Regents of the University of
 California. The software program and documentation are supplied "AS
 IS", without any accompanying services from The Regents. The Regents
 does not warrant that the operation of the program will be
 uninterrupted or error-free. The end-user understands that the program
 was developed for research purposes and is advised not to rely
 exclusively on the program for any reason.  IN NO EVENT SHALL THE
 UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
 SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS,
 ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF
 THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF
 SUCH DAMAGE. THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY
 WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE
 PROVIDED HEREUNDER IS ON AN "AS IS" BASIS, AND THE UNIVERSITY OF
 CALIFORNIA HAS NO OBLIGATIONS TO PROVIDE MAINTENANCE, SUPPORT,
 UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
             </para>
         </legalnotice>
     </bookinfo>
     <toc/>

  <chapter>
    <title>Introduction</title>
    <sect1 id="thanks">
      <title>Thanks</title>
      <para>
We, the authors, would like to take the opportunity to thank everyone
involved in the creation of this documentation, and especially the
people behind setting up the DocBook environment. In particular thanks
go out to Alejandro Ramirez, Phillipe Vanpeperstraete and Andreas
Rueckert.  Thank you!
</para>
    </sect1>

    <sect1 id="project">
      <title>About the project</title>
      <para>
ArgoUML is an open source project, so it depends on
people that volunteer to work on it. Especially in the
area of development there is still so much to do!
This Cookbook is dedicated to everyone interested in taking part
in the ArgoUML project as such and
should help to transfer the knowledge from the old experts to them.
Please feel free to send more questions and/or answers to the
<ulink url="mailto:dev@argouml.tigris.org">dev mailing list</ulink>!
</para>
    </sect1>

    <sect1>
      <title>How to contribute</title>
      <para>
You can help, there are big tasks and small tasks waiting for you.
</para>
      <para>
Here is a suggestion on how you could become
part of the ArgoUML Project.
This could be perceived as a ladder to climb but remember
that if so it is firstly a ladder of levels of commitment
and time spent by you.
You get no price for climbing higher, you just get more
responsibility in the project and more work.
</para>
      <para>
	  <orderedlist numeration="arabic">
	    <listitem>
	      <para>Use ArgoUML.</para>
	    </listitem>
	    <listitem>
	      <para>Subscribe to the dev list.</para>
	      <para>
Monitor the discussions and as soon as you see something discussed
where you have an opinion, jump right in!
</para>
	    </listitem>
	    <listitem>
	      <para>Apply for an Observer role.</para>
	      <para>
This shows that you are commited to the project and also
allows you to enter and comment on issues etc.
</para>
	    </listitem>
	    <listitem>
	      <para>
Familiarize yourself with the project and how we work.
</para>
	      <para>
Suggestion on how to go about this:
		<orderedlist numeration="loweralpha">
		  <listitem>
		    <para>
Read through most of the User manual and install and run 
the latest version of ArgoUML.
</para>
		  </listitem>
		  <listitem>
		    <para>Subscribe to the issues list.</para>
		    <para>
You will get updates on all issues so you can monitor what
we are doing in the project.
(It could be a lot of mails.
If it turns out you don't like watching issues in this way
just unsubscibe again.)
</para>
		  </listitem>
		  <listitem>
		    <para>Subscribe to the cvs list.</para>
		    <para>
You will get updates on all changes that are done 
to code, documentation, and the web site.
(It could be a lot of mails.
If it turns out you don't like watching 
what is going on in the project in this way
just unsubscibe again.)
</para>
		  </listitem>
		  <listitem>
		    <para>
Read the process part of the Developers Cookbook at
<xref linkend="processes"/>.
</para>
		    <para>
This will give you the idea of how the ArgoUML project
attempts to release with good quality and especially
how Issuezilla works.
</para>
		  </listitem>
		  <listitem>
		    <para>Get the Observer role granted.</para>
		  </listitem>
		  <listitem>
		    <para>
From this on you can report bugs yourself directly in Issuezilla.
</para>
		    <para>
You can also verify issues according to the
verification process (see <xref linkend="verify_resolved_fixed"/>).
</para>
		    <para>
This will help you understand the terminology used in the project
and also gives you an idea of the current quality of ArgoUML and
what needs to be done in the future.
</para>
		    <para>
This is also a very low-commitment level task that
could be completed in a couple of minutes
(depending on your choice of issue).
</para>
		  </listitem>
		  <listitem>
		    <para>Read the rest of the Developers Cookbook.</para>
		    <para>
There is a lot of stuff discussed in here that is interesting 
for your understanding of the project and the code.
</para>
		  </listitem>
		  <listitem>
		    <para>Check out the source from cvs and build.</para>
		  </listitem>
		</orderedlist>
</para>
	    </listitem>
	    <listitem>
	      <para>Familiarize yourself with the code.</para>
	      <para>
For this a good knowledge of Java is more or less a prerequisite.
</para>
	      <para>
Suggestion on how to go about this:
		<orderedlist numeration="loweralpha">
		  <listitem>
		    <para>
Take active part in the discussions on the dev-list.
</para>
		  </listitem>
		  <listitem>
		    <para>
Solve issues registered in Issuezilla.
</para>
		  </listitem>
		  <listitem>
		    <para>
Convince someone to commit your changes.
</para>
		  </listitem>
		  <listitem>
		    <para>
Repeat.
</para>
		    <para>
This can go on until you find that your main problem is the to get
someone to actually commit your changes, not because they are hard to
convince but because they don't have time to do commits to keep up with
your pace.
</para>
		  </listitem>
		</orderedlist>
</para>
	    </listitem>
	    <listitem>
	      <para>Apply for a Developer role.</para>
	      <para>
This allows you to do commits on your own and you can now increase
the pace in which you are working.
</para>
	    <para>
There are a lot of special requirements on you to get this granted.
</para>
	    <para>
Noted here for Linus to keep track on what to verify.
		<itemizedlist>
		  <listitem>
		    <para>
Understanding and accepting the goals.
</para>
		  </listitem>
		  <listitem>
		    <para>
Understanding where we are in the development process.
</para>
		  </listitem>
		  <listitem>
		    <para>
Understanding the terminology used in the project.
</para>
		  </listitem>
		  <listitem>
		    <para>
Good knowledge of CVS.
</para>
		  </listitem>
		  <listitem>
		    <para>
Understanding the set of tools (ant, junit) and how to use them.
</para>
		  </listitem>
	      </itemizedlist>
</para>
	  </listitem>
	    <listitem>
	      <para>Focus your work in a specific area.</para>
	      <para>
Everybody has different interests and the best contribution is made
when someone is allowed to pursue his own interests.
Hopefully ArgoUML provides you with interesting challanges to
your taste.
</para>
	    </listitem>
	    <listitem>
	      <para>Accept responsibility for a specific area.</para>
	      <para>
With this you are part of the core team developing ArgoUML.
</para>
	    </listitem>
	  </orderedlist>
</para>
    </sect1>

    <sect1>
      <title>About this Cookbook</title>
      <para>
This document, the Cookbook for Developers of ArgoUML, is provided
with the hopes of being helpful for the developers of ArgoUML when
it comes to learning and understanding how ArgoUML work in order
to improve on its functions and features. 

It can also be of interest for persons that wish to analyse the
ArgoUML project for whatever purpose that may be.
</para>
      <sect2>
	<title>In this Cookbook, you will find...</title>
	<para>
Information on how you can compile ArgoUML.
</para>
	<para>
Information on how different features of ArgoUML are implemented.
</para>
	<para>
Information on how you should add modules and Plug-ins to ArgoUML.
</para>
	<para>
Information that you, as a developer of ArgoUML,
need to know about how the project is organized and
how to contribute.
</para>

      </sect2>
      <sect2>
	<title>In this Cookbook, you will not find...</title>
	<para>
You will not find information on how to install and use ArgoUML.
</para>
	<para>
You will not find information on what UML is and if or how you should
use it in your project.
</para>
	<para>
You will not find information on how to convince your project to use
ArgoUML as a modelling tool.
</para>
      </sect2>
    </sect1>

    <sect1 id="mailing_lists">
      <title>Mailing Lists</title>
      <indexterm><primary>Mailing lists</primary></indexterm>
      <indexterm><primary>Developers' Mailing List</primary></indexterm>
      <para>
All developers <emphasis>MUST</emphasis> subscribe to the mailinglist
for developers. Please find the details at:
<ulink url="http://argouml.tigris.org/servlets/ProjectMailingListList">http://argouml.tigris.org/servlets/ProjectMailingListList</ulink>
</para>
      <indexterm>
	<primary>CVS</primary>
	<secondary>Mailing list</secondary>
      </indexterm>
      <indexterm>
	<primary>Issues</primary>
	<secondary>Mailing list</secondary>
      </indexterm>
      <para>
It is also recommended to join the CVS and Issues mailing lists.
Both give you a good idea of what is going on.
Developers should also work with Issuezilla registering or fixing 
problems found by themselves and others.
     </para>
    </sect1>

  </chapter>


  &building;
  &requirements;

<chapter id="components">
    <title>ArgoUML Design, The Big Picture</title>

    <indexterm>
      <primary>ArgoUML Design</primary>
    </indexterm>
    <para>
Currently this is more of a base for discussion and
ambition but hopefully this will mature and 
prove useful.
</para>
    <para>
The code within ArgoUML is separated in components 
that each have a responsibility.
</para>
    <para>
<xref linkend="inside_components"></xref>
explains each component in details.
This chapter just gives an overall picture.
</para>

    <indexterm>
      <primary>layer</primary>
    </indexterm>
    <para>
The components are organized in layers.
The purpose of the layers is to keep a clear view
of what components provide services to others
and to allow us to know how much is involved
when testing each component.
</para>
    <para>
TODO: Insert UML diagram describing the relation between components and layers.
</para>
    <para>
This chapter contains 
a list of all components and what layer they are in
and the definition of the responsibility of each component.
</para>

    <sect1>
      <title>Definition of component</title>
      <para>
All ArgoUML code is organized in components.
</para>
      <para>
Each component has:
<itemizedlist>
	  <listitem>
	    <para>A name</para>
	  </listitem>
	  <listitem>
	    <para>A single directory/java package where it resides</para>
	    <para>
Subparts of the component can reside in subdirectories of this directory.
Auxiliary parts of the components can reside somewhere else.
</para>
	  </listitem>
	</itemizedlist>
</para>
      <para>
Each component has a single Facade class that can be used by
all other components when using the component.
The Facade class is called
<classname><replaceable>ComponentName</replaceable>Facade</classname>
and is located in the component package.
How it is used is primarily documented in the class file itself 
(as javadoc) but the more complex picture is documented in the
Cookbook (in <xref linkend="inside_components"></xref>).
</para>
      <para>
Each component can also have one or several plug-in interfaces.
That is Facade objects where modules or plug-ins can connect themselves
to modify or augment the behavior of that component.
</para>
      <para>
The plug-in interfaces are also all located in the component package
and called
<classname><replaceable>ComponentName</replaceable>Plugin<replaceable>Plug-inType</replaceable></classname>.
Example: 
<classname>ModelPluginDiagram</classname>, 
<classname>ModelPluginType</classname>.
</para>
      <para>
If the component uses a callback-technique
the callback is always made to an interface.
The interface is also in the component package and it is called
<classname><replaceable>ComponentName</replaceable><replaceable>Plug-inType</replaceable>Interface</classname>.
Example:
<classname>ModelDiagramInterface</classname>,
<classname>ModelTypeInterface</classname>.
</para>
      <para>
        <mediaobject>
	  <imageobject>
	    <imagedata fileref="images/cookbook/ComponentDiagram.gif" format="gif"/>
	  </imageobject>
        </mediaobject>
</para>
    </sect1>

    <sect1>
      <title>Relationship of the components</title>

      <para>
Each component that is used by other components provide
two ways for other components to use them:
        <itemizedlist>
          <listitem>
            <para>
The Facade class
</para>
            <para>
The use of Facade class is not wide spread in ArgoUML.
This is because ArgoUML is traditionally built as a whole
and no components were clearly defined.
</para>
            <para>
A Facade class provides the most common functions other components
want to do when using that components to reduce the need of having
to use anything else but the Facade class.
The Facade class should be very much more stable than the component
itself.
Methods in the Facade should change really slowly and only be 
removed after several months (and one stable release) of deprecation.
</para>
            <para>
The Facade class is documented in the class file itself (as javadoc)
and the more complex picture (if needed) is documented in the
Cookbook (in <xref linkend="inside_components"></xref>).
</para>
          </listitem>
          <listitem>
            <para>
Calls to public methods
</para>
            <para>
Traditionally components interface through public methods and
public variables.
For this reason, always exercise extreme caution when changing
the signature of a public method. 
(See <xref linkend="groundrules"></xref>.)
</para>
            <para>
This way of communicating is still to be used when it is not
convenient to use the Facade for a specific use of that component.
</para>
          </listitem>
        </itemizedlist>
For each component X in ArgoUML that uses the component Y 
the designer of that component X, 
must decide if he wants to use calls to public methods
when using the component Y 
(putting a set of import org.argouml.Y.internals.blabla.*; statements
in each file in the files of component X that uses component Y)
or just use the Facade class of component Y
(putting only one import org.argouml.Y.YFacade; 
in each file in the component X that uses component Y).
</para>
            <para>
The public calls solution 
makes the component X depending on the component Y meaning
that when we change the insides of the component Y we must also change
component X.
The facade calls solution
doesn't make the component X depending on the component Y
but just the Facade of component Y.
</para>
            <para>
If the public calls solution or facade calls solution is used
shall be described in the Cookbook's description of component X
in the list of used components.
</para>
    </sect1>

    <sect1>
      <title>Definition of layer</title>

      <para>
Layers are used to organize and 
clairify the relationships between the different components
within ArgoUML.
</para>

      <para>
ArgoUML is built from the bottom and up.
Components on a higher level are relying on components
on a lower level and never the other way around.
A component cannot even rely on a component in the same layer.
</para>

      <para>
This means that when testing a component,
it can always be tested with just that component and
components on lower levels.
</para>

    </sect1>

    <sect1 id="layer0">
      <title>Layer 0 - Description of components</title>
      <para>
Layer 0 contains some infrastructure components that
just are there for every other layer to use.
</para>
      <para>
They are all insignificant enough not to be mentioned when
listing dependencies.
</para>
      <itemizedlist>

	<listitem>
	  <para>Logging</para>
	  <indexterm>
	    <primary>Logging</primary>
	  </indexterm>
	  <para>
Calls can be spread all over that would go through some rule set
and then end up on file, on the output or not at all.
</para>
	</listitem>

	<listitem>
	  <para>Internationalization</para>
	  <indexterm>
	    <primary>Internationalization</primary>
	  </indexterm>
	  <indexterm>
	    <primary>I18n</primary>
	  </indexterm>
	  <para>
This is the set of files that is a repository of localized strings.
Every other module uses these strings in all communcations with
the user.
</para>
      <para>
The Internationalization Component is described in detail in
<xref linkend="internationalization"></xref>.
</para>
	</listitem>

	<listitem>
	  <para>JRE with utils</para>
	  <indexterm>
	    <primary>JRE</primary>
	  </indexterm>
	  <para>
Every other component can use the classes available with the JRE.
</para>
	</listitem>

      </itemizedlist>
    <para>
        <mediaobject>
	  <imageobject>
	    <imagedata fileref="images/cookbook/Layer0.gif" format="gif"/>
	  </imageobject>
	</mediaobject>
</para>

    </sect1>

    <sect1 id="layer1">
      <title>Layer 1 - Description of components</title>
      <para>
Layer 1 is the lowest layer.
The components in this layer do not rely on any other part
(except layer 0)
of ArgoUML to do their work.
They can all be tested in full individually 
i.e. independant of any other component.
</para>
      <para>
<itemizedlist>

	  <listitem>
	    <para>The Model</para>
	    <indexterm>
	      <primary>Model</primary>
	    </indexterm>
	    <para>
The Model contains a modifyable view of the UML model
and the diagrams.
</para>
	    <para>
The Model presents several different views
and access methods for the information.
Among other things, the information can be saved,
loaded, examined, and observed.
</para>
	    <para>
The Model is described in detail in 
<xref linkend="model"></xref>.
</para>
	  </listitem>

	  <listitem>
	    <para>To do items</para>
	    <indexterm>
	      <primary>To Do Items</primary>
	    </indexterm>
	    <para>
This is the To do items. They can be created, deleted and saved.
</para>
	    <para>
The To Do Items Component is described in detail in 
<xref linkend="todoitems"></xref>.
</para>
	  </listitem>

	  <listitem>
	    <para>The GUI Framework</para>
	    <indexterm>
	      <primary>GUI Framework</primary>
	    </indexterm>
	    <para>
This is the framework with menus, tabs, and panes
available for the other
components to fill with actions and contents.
</para>
	    <para>
The GUI Framework Component is described in detail in 
<xref linkend="guiframework"></xref>.
</para>
	  </listitem>

	  <listitem>
	    <para>Help system</para>
	    <indexterm>
	      <primary>Help system</primary>
	    </indexterm>
	    <para>
Not yet implemented.
</para>
	    <para>
This is the component that the other components can call
to present some help for the user.
</para>
	    <para>
The Help System Component is described in detail in 
<xref linkend="help"></xref>.
</para>
	  </listitem>

	</itemizedlist>
</para>
    <para>
        <mediaobject>
	  <imageobject>
	    <imagedata fileref="images/cookbook/Layer1.gif" format="gif"/>
	  </imageobject>
	</mediaobject>
</para>
    </sect1>

    <sect1 id="layer2">
      <title>Layer 2 - Description of components</title>
      <para>
These components rely on components of layer 1 in order to do their
work.
</para>

      <para>
        <itemizedlist>
	  <listitem>
	    <para>Diagrams</para>
	    <indexterm>
	      <primary>Diagrams</primary>
	    </indexterm>
	    <indexterm>
	      <primary>Notation</primary>
	    </indexterm>
	    <para>
This is the diagram view of the model.
The notation is a property that belongs in the Diagrams
so the different language register their provided notation 
in the Diagrams component.
</para>
	    <para>
The Diagrams Component is described in detail in 
<xref linkend="diagrams"></xref>.
</para>
	  </listitem>

	  <listitem>
	    <para>Property panels</para>
	    <indexterm>
	      <primary>Property panels</primary>
	    </indexterm>
	    <para>
This is the prop panel view of the model.
</para>
	    <para>
The Property Panels Component is described in detail in 
<xref linkend="propertypanels"></xref>.
</para>
	  </listitem>

	  <listitem>
	    <para>Explorer</para>
	    <indexterm>
	      <primary>Explorer</primary>
	    </indexterm>
	    <indexterm>
	      <primary>Object Explorer</primary>
	    </indexterm>
	    <indexterm>
	      <primary>Navigator Tree</primary>
	    </indexterm>
	    <para>
This is the tree view of the model.
</para>
	    <para>
The Explorer Component is described in detail in 
<xref linkend="explorer"></xref>.
</para>
	  </listitem>

	  <listitem>
	    <para>Code Generation</para>
	    <indexterm>
	      <primary>Code Generation</primary>
	    </indexterm>
	    <para>
This is the common code for 
and the point where each language 
with Code Generation possibility registers.
</para>
	    <para>
The Code Generation Component is described in detail in 
<xref linkend="codegeneration"></xref>.
</para>
	  </listitem>

	  <listitem>
	    <para>Reverse Engineering</para>
	    <indexterm>
	      <primary>Reverse Engineering</primary>
	    </indexterm>
	    <para>
This is the common code for 
and the point where each language 
with Reverse Engineering possibility registers.
</para>
	    <para>
The Reverse Engineering Component is described in detail in 
<xref linkend="reverseengineering"></xref>.
</para>
	  </listitem>

	  <listitem>
	    <para>Module loader</para>
	    <indexterm>
	      <primary>Module loader</primary>
	    </indexterm>
	    <indexterm>
	      <primary>Pluggable interface</primary>
	    </indexterm>
	    <para>
This is the load mechanism for loading all Layer 3 components and
other modules into ArgoUML.
</para>
	    <para>
The Module Loader Component is described in detail in 
<xref linkend="moduleloader"></xref>.
</para>
	  </listitem>
	</itemizedlist>
</para>
    <para>
        <mediaobject>
	  <imageobject>
	    <imagedata fileref="images/cookbook/Layer2.gif" format="gif"/>
	  </imageobject>
	</mediaobject>
</para>
    </sect1>

    <sect1 id="layer3">
      <title>Layer 3 - Description of components</title>
      <para>
These components are primarily connected through the 
pluggable interfaces meaning that they can be
individually disabled using the module loader.
</para>

      <para>
	<itemizedlist>

	  <listitem>
	    <para>Java Code generation, Reverse engineering</para>
	    <indexterm>
	      <primary>Java</primary>
	    </indexterm>
	    <para>
This is the ArgoUML connection to the java language.
</para>
	    <para>
The Java Component is described in detail in 
<xref linkend="java"></xref>.
</para>
	  </listitem>

	  <listitem>
	    <para>Other languages - Code generation, Reverse engineering</para>
	    <para>
Languages are plugged into 
the notation,
the import (reverse engineering), 
and code generation.
</para>
	    <para>
See <xref linkend="otherlanguages"></xref>.
</para>
	  </listitem>

	  <listitem>
	    <para>Critics and checklists</para>
	    <indexterm>
	      <primary>Critics</primary>
	    </indexterm>
	    <indexterm>
	      <primary>checklists</primary>
	    </indexterm>
	    <para>
This is the critics.
</para>
	    <para>
The Critics Component is described in detail in 
<xref linkend="critics"></xref>.
</para>
	  </listitem>

	  <listitem>
	    <para>OCL</para>
	    <indexterm>
	      <primary>OCL</primary>
	    </indexterm>
	    <para>
This is the editing of the OCL strings.
</para>
	    <para>
The OCL Component is described in detail in 
<xref linkend="ocl"></xref>.
</para>
	  </listitem>

	</itemizedlist>
</para>
    <para>
        <mediaobject>
	  <imageobject>
	    <imagedata fileref="images/cookbook/Layer3.gif" format="gif"/>
	  </imageobject>
	</mediaobject>
</para>
    </sect1>

<!-- Has to be rewritten to fit the new concepts.
(If it at all will fit, I am not sure. Linus December 2002.)
    <sect1>
      <title>ArgoUML Initialization</title>
      <sect2>
	<title>Which sources are involved?</title>
	<para>
Relative to the directory org/argouml, they are mainly:
</para>
	<itemizedlist>
	  <listitem>
	    <para>
application/Main.java,
</para>
	  </listitem>
	  <listitem>
	    <para>
kernel/Project.java + xml/argo/ArgoParser.java,
</para>
	  </listitem>
	  <listitem>
	    <para>
ui/{ProjectBrowser.java,*Pane.java},
</para>
	  </listitem>
	  <listitem>
	    <para>
cognitive/{Designer.java,ui/ToDoPane.java}.
</para>
	  </listitem>
	</itemizedlist>
      </sect2>
      <sect2>
	<title>What is loaded/initialized?</title>
	<para>
It all begins in org.argouml.application.Main: set up
main application frame (org.argouml.ui.ProjectBrowser), the
project (org.argouml.kernel.Project), numerous classes, and
finally as a background thread: cognitive support
(org.argouml.cognitive.Designer) and some more classes.
</para>
	<para>
The ProjectBrowser initializes the menu, toolbar, status bar
and the four main areas:
navigation pane (org.argouml.ui.NavigatorPane),
editor pane (org.argouml.ui.MultiEditorPane),
to do pane (org.argouml.cognitive.ui.ToDoPane), and
details pane (org.argouml.ui.DetailsPane). Then, the actual
project is set to either a read from file project
(see ArgoParser.SINGLETON.readProject(URL) and
ArgoParser.SINGLETON.getProject() in org.argouml.xml.argo.ArgoParser)
or a newly generated project (see Project.makeEmptyProject()).
</para>
      </sect2>
    </sect1>
-->
<!--
Has to be rewritten.
    <sect1>
      <title>Which Objects live during a typical session?</title>
      <para>
(Project, Designer, Globals, NavPane, ToDoPane, ...)
</para>
    </sect1>
    <sect1>
      <title>What is their task?</title>
      <para>
(visual component, model, controller, ...)
</para>
    </sect1>
-->

<!--
    <sect1 id="bigger_components">
    <title>The bigger picture, ArgoUML and supporting libraries</title>
<indexterm><primary>Libraries</primary></indexterm>
<indexterm><primary>Components</primary></indexterm>
    <para>
<mediaobject>
					<imageobject>
						<imagedata format="GIF" fileref="images/cookbook/big.gif"/>
					</imageobject>
				</mediaobject>
    <itemizedlist>
      <listitem><para>Well, ArgoUML is obviously the main thing.</para></listitem>
      <listitem><para>GEF stands for <emphasis>Graph Editing Framework</emphasis>. It is the package which controls most of the graphical aspects of ArgoUML.</para></listitem>
      <listitem><para>NSUML stands for <emphasis>Novosoft UML</emphasis>. This library gives ArgoUML all the components which are required to deal with UML objects and their relationships with each other. Normally you can recognize everything out of the NSUML packages very easily because the classes start with a capital M.</para>
</listitem>
</itemizedlist>
</para>
</sect1>
-->

<!-- Move to chapter 5.
    <sect1 id="nsuml">
      <title>NS-UML</title>
      <sect2>
	<title>Tip for understanding NS-UML (from Jeremy Bennett)</title>
	<indexterm>
	  <primary>NSUML</primary>
	  <secondary>understanding</secondary>
	</indexterm>
      <para>
I found that building a javadoc for the NSUML source was quite helpful.
There are some comments in key places, and it allows you to see what
operations are available.
</para>
      <para>
Its not part of their standard distribution, so you have to generate
it yourself. Jeremy Bennet has written the following script to do it:
</para>
      <para>
makedoc.sh:
<programlisting>
#!/bin/sh

# A script to drive Javadoc for all this

###############################################################################
# The source trees for ordinary source and generated source and where we put it
# all.
NSUML_HOME=$HOME/nsuml0_4_19/nsuml
SRCDIR=${NSUML_HOME}/src
GENDIR=${NSUML_HOME}/gen
DESTDIR=${NSUML_HOME}/docs/javadocs

# Run the javadoc command
javadoc -d $DESTDIR -sourcepath $GENDIR:$SRCDIR @${NSUML_HOME}/package_list
</programlisting>
Where package_list is:
<programlisting>
ru.novosoft.uml
ru.novosoft.uml.behavior.activity_graphs
ru.novosoft.uml.behavior.collaborations
ru.novosoft.uml.behavior.common_behavior
ru.novosoft.uml.behavior.state_machines
ru.novosoft.uml.behavior.use_cases
ru.novosoft.uml.foundation.core
ru.novosoft.uml.foundation.data_types
ru.novosoft.uml.foundation.extension_mechanisms
ru.novosoft.uml.model_management
ru.novosoft.uml.undo
ru.novosoft.uml.xmi
</programlisting>
</para>
      </sect2>
      <sect2>
	<title>Tip for understanding NS-UML (from Ryan Ismert)</title>
	<indexterm>
	  <primary>NSUML</primary>
	  <secondary>understanding</secondary>
	</indexterm>
	<para>
The file docs/guide/NS_Uml_Api.html that comes in the NSUML source is
very helpful.
</para>
      </sect2>
    </sect1>
-->

<!-- This is taken care of.
<sect1 id="small">
<title>The smaller components, inside ArgoUML</title>
<para>
ArgoUML itself breaks down into several components. The graphic does not reflect the true package names, neither the true dependencies of the packages.
<mediaobject>
					<imageobject>
						<imagedata format="GIF" fileref="images/cookbook/small.gif"/>
					</imageobject>
				</mediaobject>
<itemizedlist>
<listitem><para>User Interface</para></listitem>
<listitem><para>Diagrams (see <xref linkend="diagrams"/>)</para></listitem>
<listitem><para>GEF</para></listitem>
<listitem><para>Model</para></listitem>
<listitem><para>Saving/Loading</para></listitem>
<listitem><para>Notation (see <xref linkend="notation"/>)</para></listitem>
<listitem><para>Code Generation</para></listitem>
<listitem><para>Reverse Engineering (see <xref linkend="java"/>)</para></listitem>
<listitem><para>ocl</para></listitem>
<listitem><para>Help System (see <xref linkend="help"/>)</para></listitem>
<listitem><para>Internationalization (see <xref linkend="internationalization"/>)</para></listitem>
<listitem><para>Critics and other cognitive tools (see <xref linkend="critics"/>)</para></listitem>
<listitem><para>Plugin-Module API (see <xref linkend="plugins"/>)</para></listitem>
<listitem><para>Logging (see <xref linkend="logging"/>)</para></listitem>
</itemizedlist>
</para>
</sect1>
-->


</chapter>


<chapter id="inside_components">
<title>Inside the components</title>
    <warning>
      <para>
This chapter is currently under rework with new component organization.
</para>
    </warning>
<para>...</para>

<!--
    Each section in this chapter describes a component.
    It starts with:
    Purpose - one or two sentences/lines.
    Where that component is located.
    What layer it belongs to.
 -->


    &componentmodel;
    &componentcritics;
    &componentdiagrams;
    &componentpropertypanels;

    <sect1 id="reverseengineering">
      <title>Reverse Engineering Component</title>
      <indexterm>
	<primary>Reverse Engineering</primary>
      </indexterm>
      <para>
Purpose:
Point where the different languages register that they know how to 
do reverse engineering
and common reverse engineering functions for all languages.
</para>
      <para>
The Reverse Engineering is located in
<classname>org.argouml.uml.reveng</classname>.
</para>
      <para>
The Reverse Engineering Component is a Layer 2 component.
See <xref linkend="layer2"></xref>.
</para>
    </sect1>

    <sect1 id="codegeneration">
      <title>Code Generation Component</title>
      <indexterm>
	<primary>Code Generation</primary>
      </indexterm>
      <para>
Purpose:
Point where the different languages register that they know how to 
do code generation
and common functions for all languages.
</para>
      <para>
The Code Generation is located in
<classname>org.argouml.language</classname>.
</para>
      <para>
The Code Generation component is a Layer 2 component.
See <xref linkend="layer2"></xref>.
</para>
    </sect1>



    <sect1 id="java">
      <title>Java - Code generations and Reverse Engineering</title>
      <indexterm>
	<primary>Reverse Engineering</primary>
	<secondary>Java</secondary>
      </indexterm>
      <indexterm>
	<primary>Code generation</primary>
	<secondary>Java</secondary>
      </indexterm>
      <indexterm>
	<primary>Round-trip Engineering</primary>
	<secondary>Java</secondary>
      </indexterm>
      <indexterm>
	<primary>Java</primary>
      </indexterm>
      <para>
Purpose - two purposes:
to allow the model to be converted into java code and updated either
in java or in the model;
to allow some java code to be coverted into a model.
</para>
      <para>
The java things are located in 
<classname>org.argouml.language.java</classname>.
</para>
      <para>
The Java component is a Layer 3 component. See <xref linkend="layer3"></xref>.
</para> 

<sect2 id="howdoi_reverse">
<title>How do I ...?</title>
<para>...</para></sect2>

      <sect2>
	<title>Which sources are involved?</title>
	<para>
The package org.argouml.uml.reveng is supposed to hold those classes
that are common to all RE packages. At the moment this is the Import
class which is mainly responsible to recognize directories, get their
content and parse every known source file in them. These are only java
files at the moment, but there might be other languages like C++ in
the future. With this concept you could mix several languages within
a project. The DiagramInterface is used to visualize generated NSUML
metamodel objects then.
</para>
	<para>
The package org.argouml.uml.reveng.java holds the Java specific parts
of the current RE code. C++ RE might go to org.argouml.uml.reveng.cc,
or so...
</para>
      </sect2>
      <sect2>
	<title>How is the grammar of the target language implemented?</title>
	<para>
It's an Antlr (<ulink url="http://www.antlr.org">http://www.antlr.org</ulink>)
grammar, based on the Antlr Java parser
example. The main difference is the missing AST (Abstract Syntax Tree)
generation and treeparser. So the original example generates an AST
(a treelike data structure) and then traverses this tree, while the
ArgoUML code parses the source file and generates NSUML objects
directly from the sources. This was done to avoid the memory usage
of an AST and the frequent GC while parsing many source files.
</para>
      </sect2>
      <sect2>
	<title>Which model/diagram elements are generated?</title>
	<para>
The *context classes hold the current context for a package, class
etc. When the required information for an object is available, the
corresponding NSUML object is created and passed to the DiagramInterface
to visualize it.
</para>
      </sect2>
      <sect2>
	<title>Which layout algorithm is used?</title>
	<para>
The classes in org.argouml.uml.diagram.static_structure.layout.* hold
the Classdiagram layout code. No layout for other diagram types yet.
It's based on a ranking scheme for classes and interfaces. The rank of
a class/interface depends on the total number of (direct or indirect)
superclasses. So if class B extends A (with rank(A)=0), then rank(B)=1.
If C extends B, then rank(C)=2 since it has 2 superclasses A,B. An
implemented interface is treated similar to a extended class. The
objects are placed in rows then, that depend on their rank.
rank(0)=1st row. rank(1) =2nd row (below the 1st one) etc. Example:
</para>
	<mediaobject>
	  <imageobject>
	    <imagedata fileref="images/examples/example1.gif" format="GIF"/>
	  </imageobject>
	</mediaobject>
	<para>
In the next diagramm, a link goes to an object that is not in the row
above:
</para>
	<mediaobject>
	  <imageobject>
	    <imagedata fileref="images/examples/example2.gif" format="GIF"/>
	  </imageobject>
	</mediaobject>
	<para>
In this case, insert virtual objects which are linked to the actual
target and link to them:
</para>
	<mediaobject>
	  <imageobject>
	    <imagedata fileref="images/examples/example3.gif" format="GIF"/>
	  </imageobject>
	</mediaobject>
	<para>
The objects are sorted within their row then to minimize crossing links
between them. Compute the average value of the vertical positions of all linked
objects in the row above. Example: we have 2 ranks, 0 and 1, with 3
classes each:
</para>
	<blockquote>
	  <para>
A B C : rank 0
</para>
	  <para>
D E F : rank 1
</para>
	</blockquote>
	<para>
We give the superclasses an index in their rank (assuming that they are
already sorted):
</para>
	<blockquote>
	  <para>
A:0, B:1, C:2
</para>
	</blockquote>
	<para>
D, E, F have the following links (A, B, C could be interfaces, so I allow
links to multiple superclasses here):
</para>
	<blockquote>
	  <para>
D -> C
</para>
	  <para>
E -> A and C
</para>
	  <para>
F -> A and B
</para>
	</blockquote>
	<para>
Compute the average value of the indices:
</para>
	<blockquote>
	  <para>
D = 2 (C has index 2 / 1 link)
</para>
	  <para>
E = 0 + 2 / 2 = 1 (A=0, C=2 divide by 2 links)
</para>
	  <para>
F = 0 + 1 / 2 = 0.5 (A=0, B=1, 2 links)
</para>
	</blockquote>
	<para>
Then sort the subclasses by that value:
</para>
	<blockquote>
	  <para>
F(is 0.5), E(is 1), D(is 2)
</para>
	</blockquote>
	<para>
So the placement is:
</para>
	<blockquote>
	  <para>
A B C
</para>
	  <para>
(here are the links, but I can hardly paint them as ASCIIs)
</para>
	  <para>
F E D
</para>
	</blockquote>
</sect2>



</sect1>


    <sect1 id="otherlanguages">
      <title>Other languages</title>
      <para>
Each other language supported by ArgoUML has its own component.
They are each different in level of support and implementation
language.
</para>
      <para>
Currently C++ has no reverse engineering but only code generation
(and a very simple one at that).
Java class files has only reverse engineering.
</para>
    <para>
        <mediaobject>
	  <imageobject>
	    <imagedata fileref="images/cookbook/Languages.gif" format="gif"/>
	  </imageobject>
	</mediaobject>
</para>

    </sect1>

    <sect1 id="guiframework">
      <title>The GUI Framework</title>
      <indexterm>
	<primary>GUI Framework</primary>
      </indexterm>
      <indexterm>
	<primary>Details Panel</primary>
      </indexterm>
      <para>
Purpose - Provide an infrastructure with menus, tabs and panes available
for the other components to fill with actions and contents.
</para>
      <para>
This component has no knowledge of UML, Critics, Diagrams, or Model.
</para>
      <para>
The GUI Framework is located in <classname>org.argouml.???</classname>.
</para>
      <para>
The GUI Framework is a Layer 1 component. See <xref linkend="layer1"></xref>.
</para>
      <para>
This is implemented directly on top of Swing and Java2.
</para>
      <para>
The GUI has (currently) the following main parts
<itemizedlist>
          <listitem>
	    <para>The menu</para>
          </listitem>
          <listitem>
	    <para>The toolbar</para>
	  </listitem>
	  <listitem>
	    <para>Explorer pane (Navigator pane)</para>
	    <para>Upper left.</para>
	    <para>Contains a tree of the model.</para>
	  </listitem>
	  <listitem>
	    <para>Multi editor pane</para>
	    <para>Upper right.</para>
	    <para>
Contains the diagrams (could eventually be something else).
</para>
	  </listitem>
	  <listitem>
	    <para>To do pane</para>
	    <para>Lower left.</para>
	    <para>To do items, different views.</para>
	  </listitem>
	  <listitem>
	    <para>Details pane</para>
	    <para>Lower right.</para>
	    <para>
Contains a wizard from a To do item, 
a property panel of the current object,
some other view of the current object.
</para>
	  </listitem>
	</itemizedlist>
</para>

      <sect2>
	<title>Multi editor pane</title>
	<para>
The multieditorpane is the pane with the diagram editor in it.
Normally it is placed in the upper right corner of the application.
One of the feature requests is to make the pane dockable so maybe 
it won't be there in the future.
</para>
	<para>
The multieditorpane consists of tabs that hold editors as you can see
in the classdiagram.
        <mediaobject>
	  <imageobject>
	    <imagedata fileref="images/cookbook/multieditorpane.gif" 
		       format="gif"/>
	  </imageobject>
        </mediaobject>
</para>
	<para>
At the moment there is only one editor tab in place.
This is the TabDiagram that shows an UMLDiagram, the target.
</para>
	<para>
The TabDiagram is spawnable.
This means that the user can double click the tab and the diagram will
spawn as a separate window.
</para>
	<para>
The target of the MultiEditorPane is set via the setTarget method 
of the pane.
This method is called by the setTarget method of the ProjectBrowser.
The pane's setTarget method will call each setTarget method of each
tab that is an instance of TabModelTarget.
Besides setting the target of the tabs, the setTarget method also
calls MultiEditorPane.select(Object o).
This selects the new target on a tab. This probably belongs in 
the setTarget method of the individual tabs and diagrams but 
that's how it's implemented at the moment.
</para>
	<sect3>
	  <title>How do I ...?</title>
	  <para>
<itemizedlist>
	      <listitem>
		<para>...add a new tab to the MultiEditorPane?</para>
		<para>
Create a new class that's a child of JPanel and put the following 
line in argo.ini:
<programlisting>
multi:	<replaceable>fully classified name of new tab class</replaceable>
</programlisting>
</para>
	      </listitem>
	    </itemizedlist>
</para>
	</sect3>
      </sect2>

      <sect2>
	<title>Details pane</title>
	<para>
Currently (May 2003) the Details pane contains several tabs:
Property Panels (See <xref linkend="propertypanels"></xref>,
Critics explanations and wizards (belonging to the Critics component)
(See <xref linkend="critics"></xref>),
Documentation,
Style,
Source,
Constraints (an ocl view of the current object)
(See <xref linkend="ocl"></xref>), 
and
Tagged values.
	<warning>
	  <para>
It is not clear in what component
Documentation, 
Style, 
Source,
and
Tagged values
belong.
</para>
	</warning>
</para>

      <sect3 id="howdoi_detailspanel">
	<title>How do I ...?</title>
	<para>
	  <itemizedlist>
	    <listitem>
	      <para>...add a tab in the Details Panel?</para>
	      <para>
Create your <classname>TabXXX</classname> class in 
<classname>org.argouml.uml.ui</classname> by
copying from another <filename>TabYYY.java</filename>
(e.g. <classname>TabSrc</classname>, <classname>TabStyle</classname>).
Then register your <classname>TabXXX</classname> in
<filename>org/argouml/argo.ini</filename>
by adding a line giving the compass point to place the tab.
Like - 
<programlisting>
south: 	TabXXX
</programlisting>
</para>
	    </listitem>
	    <listitem>
	      <para>...remove a tab from the Details Panel?</para>
	      <para>
Remove the line for the tab from 
<filename>org/argouml/argo.ini</filename>.
</para>
	    </listitem>
	  </itemizedlist>
</para>
	</sect3>
      </sect2>
    </sect1>


<sect1 id="help">
      <title>Help System</title>
      <indexterm>
	<primary>Help system</primary>
      </indexterm>
      <para>
Purpose - to provide the menu actions that start the help and other
documentation.
To provide infrastructure that makes context sensitive help possible.
</para>
      <para>
The Help System is not yet implemented.
</para>
      <para>
The Help System will be located in <classname>org.argouml.help</classname>.
</para>
      <para>
The Help System is a Layer 1 component. See <xref linkend="layer1"></xref>.
<!--
TODO: It however violates the layer concept by providing menu items that fit
into the GUI Framework.
-->
</para>
      <para>
Javahelp or some other help function will probably be used.
</para>

</sect1>

    &componentinternationalization;
    &cookbooklogging;


    <sect1 id="jre">
      <title>JRE with utils</title>
      <para>
Purpose - to provide the infrastructure to run everything.
</para>
      <para>
The JRE is a Layer 0 component. See <xref linkend="layer1"></xref>.
It is not distributed with ArgoUML but considered to be 
a precondition in the same respect as the user's host.
</para>
      <para>
This is a Java3 JRE so swing and awt can be used together with
reflection.
</para>
    </sect1>

    <sect1 id="todoitems">
      <title>To do items</title>
      <indexterm>
	<primary>To Do Items</primary>
      </indexterm>
      <para>
Purpose - To keep track of the To do items.
Items are generated and removed automatically by the critics.
They could also be created by other means.
</para>
      <para>
The To do items are located in
<classname>org.argouml.?</classname>
</para>
      <para>
The To do items is a Layer 1 component. See <xref linkend="layer1"></xref>.
</para>
    </sect1>


    <sect1 id="explorer">
      <title>Explorer</title>
      <para>
Purpose - to provide tree views of the model elements, 
diagrams and other objects.
</para>
      <para>
The Explorer will be located in 
<classname>org.argouml.ui.navigator ??</classname>.
</para>
      <para>
The Explorer is a Layer 2 component. See <xref linkend="layer2"></xref>.
</para>
      <para>
Several tree views are provided by means of Perspectives.
Objects showin in the trees are 
the model elements, 
diagrams and 
other objects (such as 
profiles, 
groupings of model elements etc.).
</para>
      <para>
The Explorer is currently shown in the Explorer Pane - 
the upper left hand pane of ArgoUML.
(See <xref linkend="guiframework"></xref>.)
</para>
      <para>
There is also a Explorer Configurator dialog, which allows the user
to tailor the existing perspectives and create new perspectives 
to their needs 
(although the settings are not persisted).
</para>
      <sect2>
	<title>Details of current implementation</title>
	<para>
Some of the classes are actually reused by the other tree view, 
i.e. the todo/critics list.
</para>
	<para>
The Explorer provides some 'history' capability 
(although this is disabled presently and should problably be factored out)
to navigate back to previously selected model elements. 
</para>
	<para>
Currently the Explorer Pane is mixed with the GUI framework and actions
in <classname>org.argouml.ui</classname>.
The Explorer is also dependant on "go rules", 
which are rules that help identify children nodes for and particular parent.
"Go rules" are mixed with Diagrams and Property panels 
under <classname>org.argouml.uml.diagram.ui</classname> and 
<classname>org.argouml.uml.diagram.<replaceable>diagram</replaceable>.ui</classname>.
</para>
        <para>
Explorer was previously called Navigator Tree or Navigator Pane.
</para>
      </sect2>
      <sect2>
	<title>Requirements</title>
	<para>
The Explorer must react to user and application events.
</para>
	<para>
User events include
<orderedlist continuation="restarts" spacing="compact">
	    <listitem>
	      <para>
selection of a node, 
which must notify the other views to make the same selection.
</para>
	    </listitem>
	    <listitem>
	      <para>
right click on a node, which brings up a popup menu.
</para>
	    </listitem>
	    <listitem>
	      <para>
selection of another perspective in the Combox box,
which must change the tree model to that perspective.
</para>
	    </listitem>
	    <listitem>
	      <para>
node expansion and collapse.
</para>
	    </listitem>
	  </orderedlist>
</para>
	<para>
Application Events include:
<orderedlist continuation="restarts" spacing="compact">
	    <listitem>
	      <para>
change of project, the tree must update
</para>
	    </listitem>
	    <listitem>
	      <para>
change in selection in another view, any relevant rows to be highlighted.
</para>
	    </listitem>
	    <listitem>
	      <para>
model changed, 
the tree must update to reflect additions/deletions 
and name changes in the model.
</para>
	    </listitem>
	  </orderedlist>
</para>
      </sect2>

      <sect2>
	<title>Key Classes</title>
	<para>
The Explorer contains Swing components, and there is currently
no abstraction layer (to help implement a IDE plugin for example.
</para>
	<para>
There is a <classname>JTree</classname> subclass, 
<classname>DisplayTextTree</classname>, for the tree, with a
<classname>TreeModel</classname>, Perspective.
The Perspective is made of several 'Go rules', this enables Argo to
convert the graph-like structure of a uml model into a tree and it is
easily extensible.
<mediaobject>
	    <imageobject>
	      <imagedata format="GIF" 
		         fileref="images/cookbook/classes-navigatortree.gif"/>
            </imageobject>
</mediaobject>
</para>
	<para>
There are several different ways of implementing a 
<classname>TreeModel</classname> in Swing.
ArgoUML already has a model (the NSUML MModel instance), 
so we create a class (<classname>NavPerspective</classname>) 
that encapsulates the MModel instance and 
implements <classname>TreeModel</classname> 
(contains methods that enable the JTree to calculate the tree structure).
This implementation does not build/load a tree model on instantiation,
rather it provides children nodes for any given parent node 
when the user requests a node expansion.
The <classname>NavPerspective</classname> delegates
the task of calculating child nodes to the Go rules, 
making the tree model very flexible. 
However, the price for this (at the moment) is 
slow node expansion times for large models.
</para>
	<para>
Each node is displayed with a name and an Icon, 
representing the type of node it is in the UML model. 
This is done using the 
<classname>org.argouml.uml.ui.UMLTreeRenderer</classname> (for the Icon),
and the text is produced in 
the <methodname>convertValueToText(...)</methodname> method in 
<classname>DisplayTextTree</classname>.
</para>
	<para>
Event handling is done in 
<classname>DisplayTextTree</classname> and 
<classname>NavigatorPane</classname>.
</para>
      </sect2>
      <sect2>
	<title>How do I ...?</title>
	<para>
<itemizedlist>
	    <listitem>
	      <para>...add another perspective?</para>
	      <para>
<itemizedlist>
		  <listitem>
		    <para>
at runtime perspectives can be changed using the 
<classname>NavigatorConfigDialog</classname>
</para>
		  </listitem>
		  <listitem>
		    <para>
hard code it
</para>
		    <para>
Perspectives are build in the 
<classname>NavigatorPane</classname>, 
so you can add your one there. 
Also create new Go rules that are subclasses of 
<classname>AbstractGoRule</classname>, 
then register them with the Perspetive instance using 
<methodname>addSubTreeModel(TreeModel)</methodname>.
</para>
		  </listitem>
		</itemizedlist>
</para>
	    </listitem>
	    <listitem>
	      <para>...improve the PopUp menu?</para>
	      <para>
Look in the <classname>NavigatorPane</classname> class. 
The menu is built at runtime in reaction to a mouse event.
</para>
	    </listitem>
	  </itemizedlist>
</para>
      </sect2>
    </sect1>


    <sect1 id="moduleloader">
      <title>Module loader</title>
      <para>
Purpose - to provide the mechanisms to load (and unload) the Layer 3
and auxiliary modules.
</para>
      <para>
The Module loader will be located in
<classname>org.argouml.?</classname>.
</para>
      <para>
The Module loader is a Layer 2 component. See <xref linkend="layer2"></xref>.
</para>
      <para>
Currently the module loader is located in
<classname>org.argouml.application.modules.ModuleLoader</classname>
with interfaces in
<classname>org.argouml.application.api</classname>.
</para>
      <para>
This handles the enabling and disabling of every module.
</para>
      <para>
An idea on how it could work:
It is then the modules responsibility to connect and register to
the component or components it is going to work with using that
components Facade or Plugin interface.
</para>
      <para>
For details on how to build a module
see <xref linkend="modules_and_plugins"></xref>.
</para>
      <sect2>
        <title>What the ModuleLoader does</title>
        <para>
The ModuleLoader is looking for module jars.
It actually scans through all jars available in the argo ext dir directory.
See Edit Settings Environment tab.
If you turn on logging on the debug level while running ArgoUML
you should be able to see what jar files it finds and what it does with them.
</para>
        <para>
A module jar contains the classes, resources and a manifest file.
The manifest file points out the classes to be loaded.
Also notice that the Specification-Title and Vendor must be specified
correctly for this to work.
</para>
      </sect2>
    </sect1>


    <sect1 id="ocl">
      <title>OCL</title>
      <indexterm>
	<primary>OCL</primary>
      </indexterm>
      <indexterm>
	<primary>Constraints</primary>
      </indexterm>
      <para>
Purpose - To allow for editing of strings in the OCL language.
</para>
      <para>
The OCL is located in
<classname>org.argouml.ocl</classname>.
</para>
      <para>
The OCL is a Layer 3 component. See <xref linkend="layer3"></xref>.
</para>
      <para>
The OCL editor gui interface is 
<classname>org.argouml.uml.ui.TabConstraints</classname>
(shown in the bottom right hand panel - details panel).
</para>
      <para>
<classname>org.argouml.ocl.ArgoFacade</classname> adapts the 
<classname>tudresden.ocl.gui.OCLEditor</classname> for ArgoUML.
There are some other helper classes in 
<classname>org.argouml.ocl</classname>, 
with names beginning with OCL but they are used for other purposes.
Historicaly GEF uses OCL as a kind of template language to 
convert the uml diagrams to pgml(and back again), 
it doesn't have anything to do with ocl constraints in your uml model.
</para>
      <para>
<classname>ArgoFacade</classname> is reused by 
<classname>GeneratorJava</classname> and 
<classname>TabConstraints</classname>.
</para>
      <para>
	<indexterm>
	  <primary>Dresden OCL Toolkit</primary>
	</indexterm>
Currently this component is more or less only 
Dresden OCL Toolkit
and adaptation.
</para>
    </sect1>

  </chapter>

  <chapter id="extending">
    <title>Extending ArgoUML</title>

      <para>
This section is not yet updated to discuss layers.
</para>
      <para>
This section explains some general concepts which come in handy, when 
programming in ArgoUML.
</para>

    <sect1 id="howdoi_general">
	<title>How do I ...?</title>
	<para>
<itemizedlist>
	    <listitem>
	      <para>
...get the according NS-UML element for a given
<classname>Fig<replaceable>XXX</replaceable></classname> class?
</para>
	      <para>
Each <classname>Fig<replaceable>XXX</replaceable></classname>
implements the method <methodname>getOwner()</methodname>
which returns the appropriate owner element which is
responsible for this Fig element.
</para>
	    </listitem>
	    <listitem>
	      <para>
...get the according Fig element for a given 
<classname>MModelElement</classname>?
</para>
	      <para>
for this one needs to iterate through all fig elements and invoke
<methodname>getOwner</methodname>.
Compare the result with the given <classname>MModelElement</classname>.
Beware that there might be more than one Fig Element per 
<classname>MModelElement</classname>.
</para>
	    </listitem>
	  </itemizedlist>
</para> 
    </sect1>

&cookbookmodules;

    <sect1>
      <title>How are modules organized in in the java code</title>
    <para>
This section is not yet updated to discuss layers.
</para>
      <para>
The previous section describes how modules and plugins are 
connected on the java level totally independant of how they
are actually linked into ArgoUML.
</para>
      <para>
Within the ArgoUML project some parts of the code are for
different reasons developed and kept separate from the main
ArgoUML source code.
These parts can be modules or plugins on the java level but
on the source code level they are called modules.
This section describes how they are organized and how you 
create such source-code modules.
</para>

      <sect2 id="howdoi_source_code_modules">
	<title>How do I ...?</title>
	<para>
	  <itemizedlist>
	    <listitem>
	      <para>
...create a new source-code module.
</para>
	      <para>
Suggestion, copy from the 
<filename class="directory">junit</filename>
module as described here.
</para>
	      <para>
Make a copy of
<filename class="directory">argouml/modules/junit</filename>
into 
<filename class="directory">argouml/modules/<replaceable>yourname</replaceable></filename>.
</para>
	      <para>
Remove <filename class="libraryfile">junit.jar</filename>
from
<filename class="directory">argouml/modules/<replaceable>yourname</replaceable>/lib</filename>.
</para>
	      <para>
Add any jar you need to 
<filename class="directory">argouml/modules/<replaceable>yourname</replaceable>/lib</filename>.
</para>
	      <para>
Edit
<filename class="directory">argouml/modules/<replaceable>yourname</replaceable>/module.properties</filename>
</para>
	      <para>
Edit references to
<filename class="libraryfile">junit.jar</filename> in
<filename>argouml/modules/<replaceable>yourname</replaceable>/build.xml</filename>
to any new jars you need.
</para>
	      <para>
Edit <filename>argouml/modules/yourname/src/org/manifest.mf</filename>.
</para>
	      <para>
Reorganize the source files as necessary.
Something like org.argouml.<replaceable>yourname</replaceable>
as the package root.
</para>
	    </listitem>
	    <listitem>
	      <para>
...get Argo to use a plugin?
</para>
<para>
    Once you've created a jar file with a plugin in it,
    you need to make sure that Argo can find the jar
    to be able to execute it.
</para>
<para>
    If you are using a "standard" ArgoUML source structure,
    then you should be able to execute <command>build install</command>
    or <command>ant install</command>
    in the source directory of the plugin.
    This will copy the jar file to the proper directory in the
    main ArgoUML build target.
    You can test your plugin by running <command>build run</command>
    in the <filename class="directory">src_new</filename> directory.
</para>
<para>
    If you need to install the jar "the hard way",
    try the following steps.
    <itemizedlist>
      <listitem>
         Start up ArgoUML.
      </listitem>
      <listitem>
         Go to the menu <command>Edit->Settings</command>
	 and look at the <command>Environment</command> tab.
	 Find the entry labelled <literal>${argo.ext.dir}</literal>.
         Create that directory if it does not already exist.
      </listitem>
      <listitem>
         Copy the plugin jar
	 and any other jars required by it
	 into that directory.
      </listitem>
      <listitem>
         Start up ArgoUML again,
	 and you should see the plugin's startup banner
	 (if it has one, of course).
      </listitem>

    </itemizedlist>

</para>
	    </listitem>
	  </itemizedlist>
</para>
      </sect2>
    </sect1>

</chapter>

  <chapter>
    <title>CVS repository contents</title>
    <para>
This chapter describes what parts of the CVS repository is used for
what purpose.
This is a rather terse collection.
Further details on specific parts can sometimes be found elsewhere in
this document.
</para>
    <para>
This chapter is organized as the CVS repository itself and
everything is in alphabetical order.
</para>
    <para>
<itemizedlist>
	<listitem>
	  <para><filename class="directory">build</filename></para>
	  <para>Directory where the built things end up.</para>
	  <para>
There is actually no real need to keep this in CVS.
It is there just as a place holder.
</para>
	</listitem>
	<listitem>
	  <para><filename class="directory">conf</filename></para>
	  <para>Not used. Empty.</para>
	</listitem>
	<listitem>
	  <para><filename class="directory">documentation</filename></para>
	  <para>Directory where the source of the documentation is.</para>
	  <para>
<itemizedlist>
	      <listitem>
		<para><filename class="directory">cookbook</filename></para>
		<para>XML-source code for this cookbook.</para>
	      </listitem>
	      <listitem>
		<para><filename class="directory">docbook-setup</filename></para>
		<para>
XML Tools and configuration files used for the formatting of
the documentation from the XML-source to HTML and PDF.
</para>
	      </listitem>
	      <listitem>
		<para><filename class="directory">images</filename></para>
		<para>Pictures for all documents are collected here.</para>
	      </listitem>
	      <listitem>
		<para><filename class="directory">javahelp</filename></para>
		<para>Not used. Empty.</para>
	      </listitem>
	      <listitem>
		<para><filename class="directory">manual</filename></para>
		<para>XML-source code for the User Manual.</para>
	      </listitem>
	      <listitem>
		<para><filename class="directory">quick-guide</filename></para>
		<para>XML-source code for the Quick Guide.</para>
	      </listitem>
	    </itemizedlist>
</para>
	</listitem>
	<listitem>
	  <para><filename class="directory">extra</filename></para>
	  <para>Not used. Empty.</para>
	</listitem>
	<listitem>
	  <para><filename class="directory">lib</filename></para>
	  <para>A set of jar files.</para>
	  <para>
This directory contains the jar files of products used
by the ArgoUML
(such as log4j, nsuml).
</para>
	  <para>
These are distributed with argouml and have licenses that allow this.
For clarity the README files and licenses and other distribution
details of each used jar will also be stored in this directory.
(Quick summary: BSD License, Apache License, LGPL are OK, GPL is not.)
Don't forget to arrange for the modules version and license information
to appear when starting ArgoUML and in the About box.
</para>
          <para>
Take care also to make the versions of these libraries explicit,
so as to allow people building from sources to figure out
exact dependencies. Easiest way is to rename the files to
include versioning informations, the same way as shared
libraries in Unix world: foo-x.y.z.jar, bar-x.y.z.jar,
etc...
</para>
	</listitem>
	<listitem>
	  <para><filename class="directory">modules</filename></para>
	  <para>Contains source level modules of ArgoUML.</para>
	  <para>
Source level modules are modules that can be compiled and deployed
independantly (after) the rest of ArgoUML.
Each module is located in its own subdirectory.
This is the list as it looks now (March 2003).
</para>
	  <para>
<itemizedlist>
	      <listitem>
		<para><filename class="directory">jscheme</filename></para>
		<para>
Module that allows to extend ArgoUML using scheme.
</para>
	      </listitem>
	      <listitem>
		<para><filename class="directory">junit</filename></para>
		<para>
Old directory with JUnit tests.
These should be migrated to and all new JUnit tests should be created in
the directory <filename class="directory">tests</filename>.
</para>
	      </listitem>
	      <listitem>
		<para><filename class="directory">menutest</filename></para>
		<para>
Test module that tests the plugin interface for the menus.
</para>
	      </listitem>
	      <listitem>
		<para><filename class="directory">php</filename></para>
		<para>
Language generating, Notation and reverse engineering for PHP.
</para>
	      </listitem>
	      <listitem>
		<para><filename class="directory">cpp</filename></para>
		<para>
Code generation for C++.
</para>
	      </listitem>
	      <listitem>
		<para><filename class="directory">csharp</filename></para>
		<para>
Code generation for C#.
</para>
	      </listitem>
	    </itemizedlist>
</para>
	</listitem>
	<listitem>
	  <para><filename class="directory">src</filename></para>
	  <para>
Source code.
</para>
	  <para>
This will contain one directory for each component within
ArgoUML.
They will all compile and be tested with controlled dependencies
to other components.
</para>
	</listitem>
	<listitem>
	  <para><filename class="directory">src_new</filename></para>
	  <para>
All source code for ArgoUML including pictures of icons.
</para>
	</listitem>

	<listitem>
	  <para><filename class="directory">tests</filename></para>
	  <para>
All source code for JUnit tests of everything that is in the src_new
directory.
See <xref linkend="junittests"/>.
</para>
	</listitem>

	<listitem>
	  <para><filename class="directory">tools</filename></para>
	  <para>
All tools used during the build process.
</para>
	  <para>
Tools also have the readme files, licenses and other distribution files
stored in this directory in much the same way as the libraries in
<filename class="directory">lib</filename>.
However the requirement on the license is different.
The tools are never distributed with argouml but merely used in the
development of argouml so it is enough to have a license that does not
allow distribution.
(Quick summary: BSD License, Apache license, LGPL, GPL, Freeware are OK.)
</para>
	</listitem>
	<listitem>
	  <para><filename class="directory">www</filename></para>
	  <para>
This is all the static contents of the web site.
See <xref linkend="how_the_web_site_works"/>.
</para>
	</listitem>
      </itemizedlist>
</para>
  </chapter>


  <chapter id="documentation_what_goes_where">
    <chapterinfo>
      <abstract>
	<para>
This chapter contains written down ideas on what goes into what
part of the documentation. These ideas are formulated by Linus Tolke.
</para>
      </abstract>
      <authorgroup>
	<author>
	  <firstname>Linus</firstname>
	  <surname>Tolke</surname>
	</author>
      </authorgroup>
    </chapterinfo>
    <title>Organization of ArgoUML documentation</title>
    <para>
There are seven significantly different bits of documentation in the
ArgoUML project.
By documentation I mean some information of the product that is
developed alongside the product and that has a persistant value.
</para>
    <orderedlist>
      <listitem>
	<para>The code, variablenames, class names</para>
      </listitem>
      <listitem>
	<para>The javadoc</para>
      </listitem>
      <listitem>
	<para>The cookbook</para>
      </listitem>
      <listitem>
	<para>The web site in CVS</para>
      </listitem>
      <listitem>
	<para>The manual and quick-guide</para>
      </listitem>
      <listitem>
	<para>Help texts within the running ArgoUML</para>
      </listitem>
      <listitem>
	<para>The FAQ</para>
      </listitem>
    </orderedlist>
    <para>
These different bits have all different purpose and audience and
the purpose of this chapter is to try to define that.
</para>
    <table>
      <title>Bits of documentation</title>
      <tgroup cols="4">
	<thead>
	  <row>
	    <entry>Bit</entry>
	    <entry>Audience</entry>
	    <entry>Main purpose</entry>
	    <entry>Contains</entry>
	  </row>
	</thead>
	<tbody>
	  <row>
	    <!-- Bit -->
	    <entry>The code</entry>

	    <!-- Audience -->
	    <entry>
<orderedlist>
		<listitem>
		  <para>
Other developers that will maintain and improve on the code.
</para>
		</listitem>
		<listitem>
		  <para>
The compiler.
</para>
		</listitem>
	      </orderedlist>
</entry>

	    <!-- Purpose -->
	    <entry>
Implement ArgoUML in a maintainable and understandable way.
</entry>

	    <!-- Contains -->
	    <entry>
See <xref linkend="standards"/> for more information.
</entry>
	  </row>

	  <row>
	    <!-- Bit -->
	    <entry>The javadoc</entry>

	    <!-- Audience -->
	    <entry>
Developers writing code that communicates or in other ways interact
with this class.
</entry>

	    <!-- Purpose -->
	    <entry>
Make it easy to see what the functions of every class are and how
to use them.
</entry>

	    <!-- Contains -->
	    <entry>
Description of the functions of all classes,
all public and protected methods, variables, and constants.
</entry>
	  </row>

	  <row>
	    <!-- Bit -->
	    <entry>The cookbook</entry>

	    <!-- Audience -->
	    <entry>
Developers writing code, maintaining the documentation or the web site.
</entry>

	    <!-- Purpose -->
	    <entry>
Make it easy to learn how ArgoUML works and how to extend it.
Be a collection of knowledge around how everything is set up.
Be a store of the agreed solution around fundamental design decisions
i.e. design decisions that are so big that it is meaningless to
store them in the javadoc.
Be a collection of knowledge around how and why the project makes
certain decisions.
</entry>

	    <!-- Contains -->
	    <entry>
Instructions on how to add new functions and behavior.
Instructions on how to do the chores around maintenance
(build a release, publish a release,
build the documentation part of the release,
test ArgoUML, test the documentation, ...).
Agreed project rules like what level of quality is aimed for and
description of processes that achieves that level.
</entry>
	  </row>

	  <row>
	    <!-- Bit -->
	    <entry>The web site in CVS</entry>

	    <!-- Audience -->
	    <entry>
Everyone, i.e. developers in the project, users of the product,
people searching for UML tools for the purpose of trying, testing,
evaluating, and using the tools.
</entry>

	    <!-- Purpose -->
	    <entry>
Be an entry point for the other parts of the documentation.
Be the main download area for the ArgoUML product.
Be the central point of the ArgoUML user community.
Be the central point of the ArgoUML development project.
</entry>

	    <!-- Contains -->
	    <entry>
References to all the other parts of the documentation.
Current project information like the contents of the upcoming releases
and the plan for the nearest future.
Easy access illustration for users to be.
Some illustrations that do not work well in the other 
parts of the documentation. 
This is done as a complement to the other parts. 
Examples, tours.
</entry>
	  </row>

	  <row>
	    <!-- Bit -->
	    <entry>The manual and quick-guide</entry>

	    <!-- Audience -->
	    <entry>
Users of ArgoUML.
Persons that want to evaluate ArgoUML for the purpose of starting to use it.
Persons that are training to use UML and ArgoUML.
</entry>

	    <!-- Purpose -->
	    <entry>
Describe how ArgoUML is installed and used.
Describe how UML is used with ArgoUML.
</entry>

	    <!-- Contains -->
	    <entry>
Complete installation instructions for all supported installation schemes.
Complete description on how to use ArgoUML in your project.
Complete reference on how to use ArgoUML.
</entry>
	  </row>

	  <row>
	    <!-- Bit -->
	    <entry>Help texts within the running ArgoUML</entry>

	    <!-- Audience -->
	    <entry>
Users of ArgoUML.
</entry>

	    <!-- Purpose -->
	    <entry>
Give a quick help with a specific feature or button.
Give short explanations of all commands and actions.
</entry>

	    <!-- Contains -->
	    <entry>
A complete set of quick help and explanations.
</entry>
	  </row>

	  <row>
	    <!-- Bit -->
	    <entry>The FAQ</entry>

	    <!-- Audience -->
	    <entry>
Users of ArgoUML.
Members of the users mailing list.
</entry>

	    <!-- Purpose -->
	    <entry>
Cope for shortcomings in ArgoUML, the help text, 
the Manual and quick-guide and the web site.
</entry>

	    <!-- Contains -->
	    <entry>
A list of issues that are not addressed in the other part of the documentation.
It is written in questions-answers-format and the contents is governed by
the issues discussed recently in the user community.
</entry>
	  </row>
	</tbody>
      </tgroup>
    </table>
  </chapter>

  &cvs;
  &standards;

<chapter id="further_reading">
<title>Further Reading</title>
<sect1 id="robbins">
<title>Jason Robbins Dissertation</title>
      <indexterm>
	<primary>Jason Robbins</primary>
	<secondary>Dissertation</secondary>
      </indexterm>
      <para>
Cognitive Support Features for Software Development Tools
</para>
<para>
The dissertation of Jason Robbins is a <emphasis>MUST READ</emphasis> for everyone concerned about ArgoUML. Be careful though, since it is based on an old version of ArgoUML, but many of the concepts remain intact.
</para>
      <sect2>
	<title>Abstract</title>
	<para>
Software design is a cognitively challenging task. Most software
design tools provide support for editing, viewing, storing, sharing,
and transforming designs, but lack support for the essential and
difficult cognitive tasks facing designers. These cognitive tasks
include decision making, decision ordering, and task-specific design
understanding. To date, software design tools have not included
features that specifically address key cognitive needs of designers,
in part, because there has been no practical method for developing and
evaluating these features.
</para>
	<para>
This dissertation contributes a practical description of several
cognitive theories relevant to software design, a method for devising
cognitive support features based on these theories, a basket of
cognitive support features that are demonstrated in the context of a
usable software design tool called ArgoUML, and a reusable
infrastructure for building similar features into other design tools.
ArgoUML is an object-oriented design tool that includes several novel
features that address the identified cognitive needs of software
designers. Each feature is explained with respect to the cognitive
theories that inspired it and the set of features is evaluated with a
combination of heuristic and empirical techniques.
</para>
      </sect2>
      <sect2>
	<title>Where to find it</title>
<para>LINK: <ulink url="http://argouml.tigris.org/docs/robbins_dissertation/">Robbins Dissertation</ulink>
</para>
      </sect2>
</sect1>
    <sect1 id="skinner">
      <title>Martin Skinners Dissertation</title>
      <indexterm>
	<primary>Martin Skinner</primary>
	<secondary>Dissertation</secondary>
      </indexterm>
      <para>
Enhancing an UML Modelling Tool with Context-Based Constraints for Components
</para>
      <sect2>
	<title>Abstract</title>
	<para lang="de">
Noch vor der Erstellung eines detaillierten Entwurfs hilft ein
Spezifikationsmodell eines komponenten-basierten Systems dabei, Probleme
so frh im Entwicklungsprozess wie mglich zu entdecken. Die Sprache
CCL ('Component Constraint Language') wurde bei CIS entwickelt und
erlaubt den Entwickler 'Contextbased Constraints' dem
Spezifikationsmodell hinzuzufgen. Dadurch entsteht ein Modell, das
ber die Beschreibung der statische Struktur des Systems
hinausgeht. Zur Zeit existiert allerdings kein Werkzeug, dass das
Komponentenspezifikationsmodell in den Entwicklungsprozess
integriert. Ziel dieser Diplomarbeit war der Entwurf eines solchen
Werkzeugs, um die Philosophie des Continuous Software Engineering
(CSE) zu untersttzten.

</para>
	<para>
Before starting a detailed design, a specification model of the
component-based system assists the software developer in early problem
detection as soon as possible in the development process. The
Component Constraint Language (CCL) developed at CIS enables the
developer to add context-based constraints (CoCons) to a component
specification model. This produces a model which goes beyond the
simple description of the system's static structure. At this time,
there is no tool to integrate the component specification model into
the development process. The goal of this master's thesis was to
design such a tool, thereby supporting the Continuous Software
Engineering (CSE) philosophy.
</para>
      </sect2>
      <sect2>
	<title>Where to find it</title>
	<para>
LINK: <ulink url="http://www.cocons.org/publications/CCL_plugin_for_ArgoUML.pdf">Martin Skinners dissertation</ulink>
</para>
      </sect2>
    </sect1>
</chapter>

  &processes;

  <index/>

</book>

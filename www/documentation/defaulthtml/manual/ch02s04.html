<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>2.4. Why ArgoUML is Different</title><link rel="stylesheet" href="look-and-feel.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.49"><link rel="home" href="index.html" title="ArgoUML User Manual"><link rel="up" href="ch02.html" title="Chapter 2. UML Based OOA&amp;D"><link rel="previous" href="ch02s03.html" title="2.3. UML Based Processes for OOA&amp;D"><link rel="next" href="ch02s05.html" title="2.5. ArgoUML Basics"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">2.4. Why ArgoUML is Different</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ch02s03.html">Prev</a>&nbsp;</td><th width="60%" align="center">Chapter 2. UML Based OOA&amp;D</th><td width="20%" align="right">&nbsp;<a accesskey="n" href="ch02s05.html">Next</a></td></tr></table><hr></div><div class="sect1"><div class="titlepage"><div><h2 class="title" style="clear: both"><a name="d0e905"></a>2.4. Why ArgoUML is Different</h2></div></div><p>In the introduction, we listed the four key things that make
    ArgoUML different: i) it makes use of ideas from cognitive psychology,
    ii) it is based on open standards; iii) it is 100% pure Java; and iv) it is
    an open source project.</p><div class="sect2"><div class="titlepage"><div><h3 class="title"><a name="d0e910"></a>2.4.1. Cognitive Psychology</h3></div></div><div class="sect3"><div class="titlepage"><div><h4 class="title"><a name="d0e914"></a>2.4.1.1. Theory</h4></div></div><p>ArgoUML is particularly inspired by three theories within
        cognitive psychology: i) reflection-in-action, ii) opportunistic design
        ii) and comprehension and problem solving.</p><div class="sect4"><div class="titlepage"><div><h5 class="title"><a name="d0e920"></a>2.4.1.1.1. Reflection-in-Action</h5></div></div><p>This theory observes that designers of complex systems do not
            conceive a design fully-formed. Instead, they must construct a
            partial design, evaluate, reflect on, and revise it, until they are
            ready to extend it further.</p><p>As developers work hands-on with the design, their mental model
            of the problem situation improves, hence improving their
            design.</p></div><div class="sect4"><div class="titlepage"><div><h5 class="title"><a name="d0e928"></a>2.4.1.1.2. Opportunistic Design</h5></div></div><p>A theory within cognitive psychology suggesting that although
            designers plan and describe their work in an ordered, hierarchical
            fashion, in reality, they choose successive tasks based on the
            criteria of cognitive cost.</p><p>Simply stated, designers do not follow even their own plans in
            order, but choose steps that are mentally least expensive among
            alternatives.</p></div><div class="sect4"><div class="titlepage"><div><h5 class="title"><a name="d0e936"></a>2.4.1.1.3. Comprehension and Problem Solving</h5></div></div><p>A design visualization theory within cognitive psychology. The
            theory notes that designers must bridge a gap between their mental
            model of the problem or situation and the formal model of a
            solution or system.</p><p>This theory suggests that programmers will benefit from:</p><div class="orderedlist"><ol type="1"><li><p>Multiple representations such as program syntactic
              decomposition, state transitions, control flow, and data
              flow. These allow the programmer to better identify elements and
              relationships in the problem and solution and thus more readily
              create a mapping between their situation models and working
              system models.</p></li><li><p>Familiar aspects of a situation model, which
              improve designers' abilities to formulate
              solutions.</p></li></ol></div></div></div><div class="sect3"><div class="titlepage"><div><h4 class="title"><a name="d0e951"></a>2.4.1.2. Practical Application in ArgoUML</h4></div></div><p>The implementation of these theories within ArgoUML is through
         a number of techniques.</p><div class="orderedlist"><ol type="1"><li><p>The design of a user interface which allows the user
            to view the design from a number of different perspectives, and
            allows the user to achieve goals through a number of alternative
            routes.</p></li><li><p>The the use of processes running in parallel with the
            design tool, evaluating the current design against models of how
            &#8220;best practice&#8221; design might work. These processes are
            known as <span class="emphasis"><i>design critics</i></span>.</p></li><li><p>The use of <span class="emphasis"><i>to-do lists</i></span> to convey
            suggestions from the design critics to the user, as well as
            allowing the user the record areas for future
            action.</p></li><li><p>The use of checklists, to guide the user through a
            complex process.</p></li></ol></div></div></div><div class="sect2"><div class="titlepage"><div><h3 class="title"><a name="d0e979"></a>2.4.2. Open Standards</h3></div></div><p>UML is itself an open standard. ArgoUML throughout has tried to
        use open standards for all its interfaces.</p><p>The key advantage of open standards is that it permits easy
        inter-working between applications, and the ability to move from one
        application to another as necessary.</p><p>It is this very flexibility that means some commercial software is
        not built to use standards. In a monopolistic strategy, non-standard
        interfaces lock your customer to you.</p><p>This is a two-edged sword. Customers are not stupid, and are
        reluctant to buy non-standard software, because of the danger of
        lock-in.</p><p>The open source movement, is inherently about avoiding monopolistic
        control of software. Open standards are a natural direction for such
        software&#8212;including ArgoUML.</p><div class="sect3"><div class="titlepage"><div><h4 class="title"><a name="d0e993"></a>2.4.2.1. XML Metadata Interchange (XMI)</h4></div></div><p><span class="emphasis"><i>XML Metadata Interchange (XMI)</i></span> is the
          standard for saving the meta-data that make up a particular UML
          model. In principle this will allow you to take the model you have
          created in ArgoUML and import it into another tool.</p><p>This clearly has advantages in allowing UML to meet its goal of
          being a standard for communication between designers.</p><p>The reality is not quite this good. XMI is a recent standard, and
          ArgoUML is one of the few tools to implement it. Furthermore it
          says nothing about the graphical representation of the models, so
          diagram layout is lost. ArgoUML gets round this by saving graphical
          information with the model (see <a href="ch02s05.html#s3.tut.loadsave" title="2.5.3.1. Loading and Saving">Section 2.5.3.1</a>).</p></div><div class="sect3"><div class="titlepage"><div><h4 class="title"><a name="d0e1007"></a>2.4.2.2. Standard Vector Graphics (SVG)</h4></div></div><p><span class="emphasis"><i>Standard Vector Graphics (SVG)</i></span> is a recent
          standard proposed to the W3C Standardization body (<a href="http://www.w3c.org" target="_top">www.w3c.org</a>) by Adobe (<a href="http://www.adobe.com" target="_top">www.adobe.com</a>). As yet it is not
          widely adopted, but is likely to become the standard for graphical
          data that is based on vectors (i.e. lines) rather than
          bitmaps.</p><p>For now ArgoUML saves diagrams using an earlier proposed
          standard, <span class="emphasis"><i>Portable Graphics Markup Language
          (PGML)</i></span>. However it has the option to export graphical data
          as SVG for those who can make use of it.</p></div><div class="sect3"><div class="titlepage"><div><h4 class="title"><a name="d0e1026"></a>2.4.2.3. Object Constraint Language (OCL)</h4></div></div><p><span class="emphasis"><i>Object Constraint Language (OCL)</i></span> is the
          UML standard for expressing constraints within diagrams that express
          the dynamic behavior of a design.</p><p>At present OCL is quite new and not widely available. ArgoUML
          is one of the few CASE tools to provide comprehensive support.</p></div></div><div class="sect2"><div class="titlepage"><div><h3 class="title"><a name="d0e1036"></a>2.4.3. 100% Pure Java</h3></div></div><p>Java was conceived as an interpreted language. It doesn't have a
        compiler to produce code for any particular target machine. It compiles
        code for its own target, the <span class="emphasis"><i>Java Virtual Machine
        (JVM)</i></span>.</p><p>Writing an interpreter for a JVM is much easier than writing a
        compiler, and such machines are now incorporated into almost every Web
        Browser. As a result most machines can run Java, with no further
        work.</p><p>(In case you wonder why all languages aren't like this, it is
        because interpreted languages tend to be slower than compiled
        languages. However with the high performance of modern PCs, the
        trade-off for portability is worthwhile for many
        applications. Furthermore modern multi-level caches can mean that
        interpreted languages, which produce denser code, may actually not be
        that much slower anyway.)</p><p>By choosing to write ArgoUML in pure Java, it is immediately made
        available to the maximum number of users with the minimum amount of
        effort.</p></div><div class="sect2"><div class="titlepage"><div><h3 class="title"><a name="d0e1051"></a>2.4.4. Open Source</h3></div></div><p>ArgoUML is an <span class="emphasis"><i>open source</i></span> project. That
        means anyone can have a free copy of the source code, change it, use it
        for new purposes and so on. The only (major) obligation is that you
        pass your code on in the same way to others. The precise nature of what
        you can and can't do varies from project to project, but the principle
        is the same.</p><p>The advantage is that a small project like ArgoUML suddenly is
        open to a lot of additional help from those who can chip in their ideas
        for how the program might be improved. At any one time their may be 10,
        15, 20 or more people making significant contributions to ArgoUML. To
        do that commercially would cost $1m+ per year.</p><p>Its not just a spirit of pure altruism. Contributing is a way of
        learning &#8220;hands-on&#8221; about leading edge software. Its a way
        of getting a lot of visibility (over 100,000 people had downloaded
        ArgoUML by the spring of 2001). That's a lot of good experience on a
        resum&eacute; and a lot of potential employers seeing you!</p><p>And its great for the ego!</p><p>Open Source doesn't preclude making money. Gentleware <a href="http://www.gentleware.com" target="_top">www.gentleware.com</a> sell a
        commercial version of ArgoUML, Poseidon. Their value proposition is
        not a piece of private code. Its the commercial polish and support that
        take risk out of using ArgoUML in a commercial development, allowing
        customers to take advantage of ArgoUML's leading edge
        technology.</p></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch02s03.html">Prev</a>&nbsp;</td><td width="20%" align="center"><a accesskey="u" href="ch02.html">Up</a></td><td width="40%" align="right">&nbsp;<a accesskey="n" href="ch02s05.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">2.3. UML Based Processes for OOA&amp;D&nbsp;</td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top">&nbsp;2.5. ArgoUML Basics</td></tr></table></div></body></html>
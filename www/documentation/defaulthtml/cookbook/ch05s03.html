<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>5.3.&nbsp;Diagrams</title><link rel="stylesheet" href="look-and-feel.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.66.1"><link rel="start" href="index.html" title="Cookbook for Developers of ArgoUML"><link rel="up" href="ch05.html" title="Chapter&nbsp;5.&nbsp;Inside the subsystems"><link rel="prev" href="ch05s02.html" title="5.2.&nbsp;Critics and other cognitive tools"><link rel="next" href="ch05s04.html" title="5.4.&nbsp;Property panels"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">5.3.&nbsp;Diagrams</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ch05s02.html">Prev</a>&nbsp;</td><th width="60%" align="center">Chapter&nbsp;5.&nbsp;Inside the subsystems</th><td width="20%" align="right">&nbsp;<a accesskey="n" href="ch05s04.html">Next</a></td></tr></table><hr></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="diagrams"></a>5.3.&nbsp;Diagrams</h2></div></div></div><a class="indexterm" name="d0e4401"></a><a class="indexterm" name="d0e4404"></a><p>
Purpose - To present the diagrams to the user and allow the user to manipulate
the diagrams through the view.
</p><p>
The Diagrams are be located in <tt class="classname">org.argouml.uml.diagram</tt>.
</p><p>
The Diagrams is a View subsystem. <a href="ch04s05.html" title="4.5.&nbsp;View and Control subsystems">Section&nbsp;4.5, &#8220;View and Control subsystems&#8221;</a>.
</p><p>
The Diagrams are depending on the Model subsystem and the GUI.
</p><p>
The classes in this subsystem are extensions of the GEF base classes
(GraphModels, Figs, Selections etc) together with some supporting classes.
</p><p>
This subsystem has no direct access to a specific implementation of the OMG
model repository. However it does update such a repository via the interface of
the Model Subsystem.
</p><p>
There is an intention (Bob Tarling) to split this subsystem into several smaller
subsystems, one for each diagram type. This is to allow for indiviual diagram
reuse by other applications and to allow us to fast track developers onto a
specific subproject containing that subsystem (Michael MacDonald and sequence
diagrams in mind).
</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e4426"></a>5.3.1.&nbsp;Multi editor pane</h3></div></div></div><p>
The multi editor pane is the pane with the diagram editor in it.
Normally it is placed in the upper right corner of the application.
One of the feature requests is to make the pane dockable so maybe 
it won't be there in the future.
</p><p>
The multi editor pane consists of tabs that hold editors as you can see
in the class diagram.
        </p><div class="mediaobject"><img src="images/cookbook/multieditorpane.gif"></div><p>
</p><p>
At the moment there is only one editor tab in place.
This is the <tt class="classname">TabDiagram</tt> that shows an UMLDiagram, 
the target.
</p><p>
The <tt class="classname">TabDiagram</tt> is spawn-able.
This means that the user can double click the tab and the diagram will
spawn as a separate window.
</p><p>
The target of the <tt class="classname">MultiEditorPane</tt> is set via the 
<tt class="methodname">setTarget</tt> method 
of the pane.
This method is called by the <tt class="methodname">setTarget</tt> method 
of the <tt class="classname">ProjectBrowser</tt>.
The pane's <tt class="methodname">setTarget</tt> method 
will call each <tt class="methodname">setTarget</tt> method of 
each tab that is an instance of <tt class="classname">TabModelTarget</tt>.
Besides setting the target of the tabs, 
the <tt class="methodname">setTarget</tt> method also
calls <tt class="classname">MultiEditorPane</tt>.select(Object o).
This selects the new target on a tab. This probably belongs in 
the <tt class="methodname">setTarget</tt> method of the individual tabs and diagrams but 
that's how it's implemented at the moment.
</p><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e4479"></a>5.3.1.1.&nbsp;How do I ...?</h4></div></div></div><p>
</p><div class="itemizedlist"><ul type="disc"><li><p>...add a new tab to the <tt class="classname">MultiEditorPane</tt>?</p><p>
Create a new class that's a child of <tt class="classname">JPanel</tt> 
and put the following 
line in argo.ini:
</p><pre class="programlisting">
multi:	<i class="replaceable"><tt>fully classified name of new tab class</tt></i>
</pre><p>
</p></li></ul></div><p>
</p></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="howdoi_diagrams"></a>5.3.2.&nbsp;How do I add a new element to a diagram?</h3></div></div></div><p>
To add a new element to a diagram, two main things have to be done.
</p><div class="orderedlist"><ol type="1"><li><p>
Create new Fig classes to represent the element on the
diagram and add them to the graph model 
(org.argouml.uml.diagram.xxxx.XxxxDiagramGraphModel.java)
and renderer
(org.argouml.uml.diagram.xxxx.ui.XxxxDiagramRenderer.java).
</p></li><li><p>
Create a new property panel class that will be displayed in
the property tab window on the details pane.
This is described in <a href="ch05s04.html" title="5.4.&nbsp;Property panels">Section&nbsp;5.4, &#8220;Property panels&#8221;</a>.
</p></li></ol></div><p>
Throughout we shall use the example of adding the UML Extend
relationship to a use case diagram. This allows two Use Cases to be
joined by a dotted arrow labeled
<tt class="literal">&laquo;extend&raquo;</tt> to show that one extends the
behavior of the other.
</p><p>
The classes involved in this particular example have all been well
commented and have full Javadoc descriptions, to help when examining
the code. 
You will need to read the description here in conjunction
with looking at the code.
</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e4524"></a>5.3.3.&nbsp;How to add a new Fig</h3></div></div></div><p>
The new item must be added to the tool-bar. Both the graph model and
diagram renderer for the diagram will need modifying for any new fig
object.
</p><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e4529"></a>5.3.3.1.&nbsp;Adding to the tool-bar</h4></div></div></div><p>
Find the diagram object in
<tt class="filename">uml/diagram/<i class="replaceable"><tt>XXXX</tt></i>/ui/UML<i class="replaceable"><tt>YYYY</tt></i>Diagram.java</tt>, 
where
<i class="replaceable"><tt>XXXX</tt></i> is the diagram type (lower case) and
<i class="replaceable"><tt>YYYY</tt></i> the diagram type (bumpy caps). For example
<tt class="filename">uml/diagram/use_case/ui/UMLUseCaseDiagram.java</tt>. 
This will be a subclass of UMLDiagram (in
<tt class="filename">uml/diagram/ui/UMLDiagram.java</tt>).
</p><p>
Each tool-bar action is declared as a protected static field of class
<tt class="classname">Action</tt>, initiated as a 
<tt class="literal">new CmdCreateNode</tt> (for nodal UML elements) or a
<tt class="literal">new CmdSetMode</tt> (for behavior, or creation of line
UML elements). These classes are part of the GEF library.
</p><p>
The common ones (select, broom, graphic annotations) are inherited
from UMLDiagram, the diagram specific ones in the class itself. For
example in UMLUseCaseDiagram.java we have the following for creating
Use Case nodes.
</p><pre class="programlisting">
protected static Action _actionUseCase =
    new CmdCreateNode(ModelFacade.USE_CASE, "UseCase");
</pre><p>
</p><p>
The first argument is the class of the node to create from NSUML, the
second a textual tool tip.
</p><p>For creating associations we have:</p><pre class="programlisting">
protected static Action _actionAssoc =
      new CmdSetMode(ModeCreatePolyEdge.class,
	   	     "edgeClass", MAssociationImpl.class,
		     "Association");
</pre><p>
</p><p>
The first argument is a GEF class that defines the type of behavior
wanted (in this case creating a poly-edge). The second and third
arguments are a named parameter used by
<tt class="classname">ModeCreatePolyEdge</tt> ("edgeClass") and its value
(<tt class="literal">MAssociationImpl.class</tt>). The final argument is a
tooltip.
</p><p>
The tool-bar is actually created by defining a method,
<tt class="methodname">initToolBar()</tt> which adds the tools in turn to the
tool-bar (a protected member named <tt class="literal">_toolBar</tt>).
</p><p>
The default constructor for the diagram is declared private, since it
must not be called directly. The desired constructor takes a name-space
as an argument, and sets up a graph model
(<tt class="classname">UseCaseDiagramGraphModel</tt>), layer perspective and
renderer (<tt class="classname">UseCaseDigramRenderer</tt>) for nodes and
edges.
</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e4605"></a>5.3.3.2.&nbsp;Changing the graph model</h4></div></div></div><p>
The graph model is the bridge between the UML meta-model
representation of the design and the graph model of GEF. They are
found in the parent directory of the corresponding diagram class, and
have the general name 
<tt class="filename"><i class="replaceable"><tt>YYYY</tt></i>DiagramGraphModel.java</tt>,
where <i class="replaceable"><tt>YYYY</tt></i> is the diagram name in bumpy caps. For
example the use case diagram graph model is in
<tt class="filename">uml/diagram/use_case/UseCaseDiagramGraphModel.java</tt>
</p><p>
The graph model is defined as 
<tt class="classname">UMLMutableGraphSupport</tt>,
a child of the GEF class
<tt class="classname">MutableGraphSupport</tt>, and should implement
<tt class="classname">MutableGraphModel</tt> (GEF).
</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e4632"></a>5.3.3.3.&nbsp;Changing the renderer</h4></div></div></div><p>
The renderer is responsible for creating graphic figs as required on
the diagram. It is found in the same directory of the corresponding
diagram class, and has the general name
<tt class="filename"><i class="replaceable"><tt>YYYY</tt></i>DiagramRenderer.java</tt>, where
<i class="replaceable"><tt>YYYY</tt></i> is the diagram name in bumpy caps. For example
the use case diagram graph model is in
<tt class="filename">uml/diagram/use_case/ui/UseCaseDiagramRenderer.java</tt>
</p><p>
This provides two routines, <tt class="methodname">getFigNodeFor()</tt>, which
provides a fig object to represent a given NSUML node object and
<tt class="methodname">getFigEdgeFor()</tt>, which provides a fig object to
represent a given NSUML edge object.
</p><p>
In our example, we must extend <tt class="methodname">getFigEdgeFor()</tt> so
it can handle NSUML MExtend objects (producing a
<tt class="classname">FigExtend</tt>).
</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e4664"></a>5.3.3.4.&nbsp;Creating a new Fig (explanation 1)</h4></div></div></div><p>
New objects that are to appear on a diagram will require new Fig
classes to represent them. In our example we have created
FigExtend. They are placed in the same directory as the diagram that
uses them.
</p><p>
The implementation must provide constructors for both a generic fig,
and one representing a specific NSUML object. It should provide a
setFig() method to set a particular figure as the representation. It
should provide a method canEdit() to indicate whether the Fig can be
edited. It should provide an event handler modelChanged() to cope with
advice that the model has changed.
</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="howto_createnewfig_2"></a>5.3.3.5.&nbsp;Creating a new Fig (explanation 2)</h4></div></div></div><p>
Assuming you have your model element already defined in the model
and your PropPanel for that model element
you should make the Fig class. 

            </p><div class="orderedlist"><ol type="1"><li><p>
For nodes, that are Figs that are enclosed figures like 
<tt class="classname">FigClass</tt>, 
extend from <tt class="classname">FigNodeModelElement</tt>. 
For edges, that are lines like <tt class="classname">FigAssociation</tt>, 
extend from <tt class="classname">FigEdgeModelElement</tt>.
The name of the Fig has to start with (yes indeed) Fig. 
The rest of the name should be equal to the model element name.
</p></li><li><p>
Create a default constructor in the Fig.
In this default constructor the drawing of the actual figure is done.
Here you draw the lines and text fields.
See <tt class="classname">FigClass</tt> and 
<tt class="classname">FigAssociation</tt> for an example of this.
</p></li><li><p>
Create a constructor 
<tt class="methodname">FigMyModelelement(Object owner)</tt>.
Set the owner in this method by calling <tt class="methodname">setOwner</tt>.
Make a method <tt class="methodname">setOwner</tt> that overrides
it's super. 
Let the method call it's super.
Set all attributes of the Fig with data from it's owner 
in this <tt class="methodname">setOwner</tt> method. 
See <tt class="methodname">setOwner</tt> of 
<tt class="classname">FigAssociation</tt> for an example.
</p></li><li><p>
Create an overridden method 
<tt class="methodname">protected void modelChanged()</tt>.
This method must be called (and is if you implement the fig correctly)
if the owner changes.
In this method you update the fig if the model is changed. 
See <tt class="classname">FigAssociation</tt> and 
<tt class="classname">FigClass</tt> for an example.
</p></li><li><p>
If you have text that can be edited, override the method
<tt class="methodname">textEdited(FigText text)</tt>.
In this method the edited text is parsed. 
If the parsing is simple and not Notation specific, just do it in textEdited.
But for most cases: delegate to ParserDisplay. 
See the method <tt class="methodname">parseAttribute</tt>
in ParserDisplay for an example. 
Stick to the Notation you are using to have the right parsing scheme.
There is work to be done here but please don't make it an even bigger mess :)
</p></li><li><p>
Make an Action that can be called from the GUI.
If you are lucky, you just can use <tt class="classname">CmdCreateNode</tt>.
See for examples <tt class="classname">UMLClassDiagram</tt> of using
<tt class="classname">CmdCreateNode</tt>.
</p></li><li><p>
Adapt the method <tt class="methodname">canAddEdge(Object o)</tt>
on subclasses of <tt class="classname">GraphModel</tt> if
you are building an edge so it will return true if the edge may be added
to the subclass. 
Subclasses are for example <tt class="classname">ClassDiagramGraphModel</tt> and
<tt class="classname">UseCaseDiagramGraphModel</tt>.
If you are building a node, adapt
<tt class="methodname">canAddNode(Object o)</tt>.
</p></li><li><p>
Adapt the method <tt class="methodname">getFigEdgeFor</tt> on
implementors of <tt class="classname">GraphEdgeRenderer</tt> if
you are implementing an edge so it will return the correct 
<tt class="classname">FigEdge</tt> for your object. 
If you are implementing a node, adapt the method 
<tt class="methodname">getFigNodeFor</tt> on
implementors of <tt class="classname">GraphNodeRenderer</tt>.
In ArgoUML classes like <tt class="classname">ClassDiagramRenderer</tt>
implement these interfaces.
</p></li><li><p>
Add an image file for the buttons to the resource directory
<tt class="filename">org/argouml/Images</tt>.
This image file must be of GIF format and have a
drawing of the button image to be used in itself.
This image is also used on the PropPanel.
The name of the Image file should be 
<tt class="filename"><i class="replaceable"><tt>model element</tt></i>.gif</tt>
</p></li><li><p>
Add buttons to the action you created on those places in the GUI that
have a need for it.
This should be at least the button bar in each diagram
where you can draw your model element.
Probably the parent of your model element (e.g. class in case of operation) 
will want a button too, so add it to the PropPanel of the parent. 
In case of the diagrams, add it in 
<tt class="filename">UML<i class="replaceable"><tt>diagram</tt></i>.java</tt>, 
so in <tt class="classname">UMLClassDiagram</tt> if it belongs there. 
In case of the <tt class="classname">PropPanel</tt>s, most of them don't use actions,
they implement them directly as methods in the PropPanel themselves.
Please don't do that but use an action so we have one place of definition.
</p></li></ol></div><p>
          </p></div></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch05s02.html">Prev</a>&nbsp;</td><td width="20%" align="center"><a accesskey="u" href="ch05.html">Up</a></td><td width="40%" align="right">&nbsp;<a accesskey="n" href="ch05s04.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">5.2.&nbsp;Critics and other cognitive tools&nbsp;</td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top">&nbsp;5.4.&nbsp;Property panels</td></tr></table></div></body></html>
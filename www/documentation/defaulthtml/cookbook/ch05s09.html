<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>5.9.&nbsp;Java - Code generations and Reverse Engineering</title><link rel="stylesheet" href="look-and-feel.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.66.1"><link rel="start" href="index.html" title="Cookbook for Developers of ArgoUML"><link rel="up" href="ch05.html" title="Chapter&nbsp;5.&nbsp;Inside the subsystems"><link rel="prev" href="ch05s08.html" title="5.8.&nbsp;Code Generation Subsystem"><link rel="next" href="ch05s10.html" title="5.10.&nbsp;Other languages"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">5.9.&nbsp;Java - Code generations and Reverse Engineering</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ch05s08.html">Prev</a>&nbsp;</td><th width="60%" align="center">Chapter&nbsp;5.&nbsp;Inside the subsystems</th><td width="20%" align="right">&nbsp;<a accesskey="n" href="ch05s10.html">Next</a></td></tr></table><hr></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="java"></a>5.9.&nbsp;Java - Code generations and Reverse Engineering</h2></div></div></div><a class="indexterm" name="d0e6548"></a><a class="indexterm" name="d0e6553"></a><a class="indexterm" name="d0e6558"></a><a class="indexterm" name="d0e6563"></a><p> Purpose - two purposes: to allow the model to be converted into java code
      and updated either in java or in the model; to allow some java code to be
      converted into a model. </p><p> The java things are located in
      <tt class="classname">org.argouml.language.java</tt>. </p><p> The Java subsystem is a Loadable subsystem. See <a href="ch04s06.html" title="4.6.&nbsp;Loadable subsystems">Section&nbsp;4.6, &#8220;Loadable subsystems&#8221;</a>. </p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="howdoi_reverse"></a>5.9.1.&nbsp;How do I ...?</h3></div></div></div><p>...</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e6582"></a>5.9.2.&nbsp;Which sources are involved?</h3></div></div></div><p> The package org.argouml.uml.reveng is supposed to hold those
        classes that are common to all RE packages. At the moment this is the Import
        class which is mainly responsible to recognize directories, get their
        content and parse every known source file in them. These are only java
        files at the moment, but there might be other languages like C++ in the
        future. With this concept you could mix several languages within a
        project. The DiagramInterface is used to visualize generated NSUML
        meta-model objects then. </p><p> The package org.argouml.uml.reveng.java holds the Java specific
        parts of the current RE code. C++ RE might go to
        org.argouml.uml.reveng.cc, or so... </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e6589"></a>5.9.3.&nbsp;How is the grammar of the target language implemented?</h3></div></div></div><p> It's an Antlr (<a href="http://www.antlr.org" target="_top">
        http://www.antlr.org</a>) grammar, based on the Antlr Java parser
        example. The main difference is the missing AST (Abstract Syntax Tree)
        generation and tree-parser. So the original example generates an AST (a
        treelike data structure) and then traverses this tree, while the ArgoUML
        code parses the source file and generates NSUML objects directly from the
        sources. This was done to avoid the memory usage of an AST and the frequent
        GC while parsing many source files. </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e6597"></a>5.9.4.&nbsp;Which model/diagram elements are generated?</h3></div></div></div><p> The *context classes hold the current context for a package, class
        etc. When the required information for an object is available, the
        corresponding NSUML object is created and passed to the
        DiagramInterface to visualize it. </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e6602"></a>5.9.5.&nbsp;Which layout algorithm is used?</h3></div></div></div><p> The classes in
        org.argouml.uml.diagram.static_structure.layout.* hold the Class
        diagram layout code. No layout for other diagram types yet. It's based on a
        ranking scheme for classes and interfaces. The rank of a class/interface
        depends on the total number of (direct or indirect) super-classes. So if
        class B extends A (with rank(A)=0), then rank(B)=1. If C extends B, then
        rank(C)=2 since it has 2 super-classes A,B. An implemented interface is
        treated similar to a extended class. The objects are placed in rows then,
        that depend on their rank. rank(0)=1st row. rank(1) =2nd row (below the
        1st one) etc. Example: </p><div class="mediaobject"><img src="images/examples/example1.gif"></div><p> In the next diagram, a link goes to an object that is not in the row
        above: </p><div class="mediaobject"><img src="images/examples/example2.gif"></div><p> In this case, insert virtual objects which are linked to the actual
        target and link to them: </p><div class="mediaobject"><img src="images/examples/example3.gif"></div><p> The objects are sorted within their row then to minimize crossing
        links between them. Compute the average value of the vertical positions
        of all linked objects in the row above. Example: we have 2 ranks, 0 and 1,
        with 3 classes each: </p><div class="blockquote"><blockquote class="blockquote"><p> A B C : rank 0 </p><p> D E F : rank 1 </p></blockquote></div><p> We give the super-classes an index in their rank (assuming that they
        are already sorted): </p><div class="blockquote"><blockquote class="blockquote"><p> A:0, B:1, C:2 </p></blockquote></div><p> D, E, F have the following links (A, B, C could be interfaces, so I allow
        links to multiple super-classes here): </p><div class="blockquote"><blockquote class="blockquote"><p> D -&gt; C </p><p> E -&gt; A and C </p><p> F -&gt; A and B </p></blockquote></div><p> Compute the average value of the indexes: </p><div class="blockquote"><blockquote class="blockquote"><p> D = 2 (C has index 2 / 1 link) </p><p> E = 0 + 2 / 2 = 1 (A=0, C=2 divide by 2 links) </p><p> F = 0 + 1 / 2 = 0.5 (A=0, B=1, 2 links) </p></blockquote></div><p> Then sort the subclasses by that value: </p><div class="blockquote"><blockquote class="blockquote"><p> F(is 0.5), E(is 1), D(is 2) </p></blockquote></div><p> So the placement is: </p><div class="blockquote"><blockquote class="blockquote"><p> A B C </p><p> (here are the links, but I can hardly paint them as ASCIIs) </p><p> F E D </p></blockquote></div></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch05s08.html">Prev</a>&nbsp;</td><td width="20%" align="center"><a accesskey="u" href="ch05.html">Up</a></td><td width="40%" align="right">&nbsp;<a accesskey="n" href="ch05s10.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">5.8.&nbsp;Code Generation Subsystem&nbsp;</td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top">&nbsp;5.10.&nbsp;Other languages</td></tr></table></div></body></html>
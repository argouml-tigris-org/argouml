<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ClassdiagramNode.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">argouml-app</a> &gt; <a href="index.source.html" class="el_package">org.argouml.uml.diagram.static_structure.layout</a> &gt; <span class="el_source">ClassdiagramNode.java</span></div><h1>ClassdiagramNode.java</h1><pre class="source lang-java linenums">/* $Id$
 *****************************************************************************
 * Copyright (c) 2009 Contributors - see below
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    tfmorris
 *****************************************************************************
 *
 * Some portions of this file was previously release using the BSD License:
 */

// Copyright (c) 1996-2008 The Regents of the University of California. All
// Rights Reserved. Permission to use, copy, modify, and distribute this
// software and its documentation without fee, and without a written
// agreement is hereby granted, provided that the above copyright notice
// and this paragraph appear in all copies.  This software program and
// documentation are copyrighted by The Regents of the University of
// California. The software program and documentation are supplied &quot;AS
// IS&quot;, without any accompanying services from The Regents. The Regents
// does not warrant that the operation of the program will be
// uninterrupted or error-free. The end-user understands that the program
// was developed for research purposes and is advised not to rely
// exclusively on the program for any reason.  IN NO EVENT SHALL THE
// UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
// SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS,
// ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF
// THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE. THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY
// WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE
// PROVIDED HEREUNDER IS ON AN &quot;AS IS&quot; BASIS, AND THE UNIVERSITY OF
// CALIFORNIA HAS NO OBLIGATIONS TO PROVIDE MAINTENANCE, SUPPORT,
// UPDATES, ENHANCEMENTS, OR MODIFICATIONS.

package org.argouml.uml.diagram.static_structure.layout;

import java.awt.Dimension;
import java.awt.Point;
import java.util.ArrayList;
import java.util.List;

import org.argouml.uml.diagram.layout.LayoutedNode;
import org.argouml.uml.diagram.static_structure.ui.FigComment;
import org.argouml.uml.diagram.static_structure.ui.FigInterface;
import org.argouml.uml.diagram.static_structure.ui.FigPackage;
import org.tigris.gef.presentation.Fig;
import org.tigris.gef.presentation.FigNode;

/**
 * This class represents a node in the classdiagram (a class, interface or
 * package).
 * &lt;p&gt;
 * 
 * Things a node has to know:
 * &lt;ul&gt;
 * &lt;li&gt;Up- and downlinks for positioning in the hierarchy
 * &lt;li&gt;Weight of this node. This weight has to be strongly influenced by the
 * parent-nodes, because otherwise the order of nodes in the current row will
 * not be compatible with the order of the nodes in the row above.
 * &lt;/ul&gt;
 */
class ClassdiagramNode implements LayoutedNode, Comparable {

    /**
     * Constant to be used as an initializer when this node is not placed at an
     * column.
     */
    public static final int NOCOLUMN = -1;

    /**
     * Constant to be used as an initializer when this node has no rank assigned
     * yet.
     */
    public static final int NORANK = -1;

    /**
     * Constant to be used as an initializer when this node has no weight.
     */
    public static final int NOWEIGHT = -1;

    /**
     * The current column of this node.
     */
<span class="nc" id="L88">    private int column = NOCOLUMN;</span>

    /**
     * List of the nodes that contain the figures, which
     * are sources of edges with the figure of this node as destination.
     */
<span class="nc" id="L94">    private List&lt;ClassdiagramNode&gt; downlinks = </span>
        new ArrayList&lt;ClassdiagramNode&gt;();

    /**
     * Offset used for edges, which have this node as the &quot;upper&quot; node.
     */
<span class="nc" id="L100">    private int edgeOffset = 0;</span>

    /**
     * The Fig that this ClassdiagramNode represents during the layout process.
     */
<span class="nc" id="L105">    private FigNode figure = null;</span>

    /**
     * The preferred X coordinate for the node.  Hint only. May not be used.
     */
<span class="nc" id="L110">    private int placementHint = -1;</span>

    /**
     * The current rank (i.e. row number) of this node.
     */
<span class="nc" id="L115">    private int rank = NORANK;</span>

    /**
     * List of nodes that contain the figures, which are destinations of edges
     * with the figure of this node as source.
     */
<span class="nc" id="L121">    private List&lt;ClassdiagramNode&gt; uplinks = new ArrayList&lt;ClassdiagramNode&gt;();</span>

    /**
     * The 'weight' of this node. This is a computed
     * attribute that is used during the horizontal placement process. It's
     * based on the position of the 'uplinked' objects. The actual purpose is to
     * minimize the number of link crossings in the diagram. Since we don't
     * compute the actual number of link crossings, we look where our uplinked
     * objects are, and then try to place our object in a way, that we can
     * expect to have a minimal number of crossings.
     */
<span class="nc" id="L132">    private float weight = NOWEIGHT;</span>

    private static final float UPLINK_FACTOR = 5;

    /**
     * Construct a new ClassdiagramNode representing the given Fig.
     * 
     * @param f
     *            represents the figure in the diagram, that peers this layout
     *            node.
     */
<span class="nc" id="L143">    public ClassdiagramNode(FigNode f) {</span>
<span class="nc" id="L144">        setFigure(f);</span>
<span class="nc" id="L145">    }</span>

    /**
     * Add a new downlinked node to this node.
     * 
     * @param newDownlink
     *            The node to be added with a dowlink.
     */
    public void addDownlink(ClassdiagramNode newDownlink) {
<span class="nc" id="L154">        downlinks.add(newDownlink);</span>
<span class="nc" id="L155">    }</span>

    /**
     * Add a constant to the rank of this node.
     * 
     * @param n
     *            The value to add.
     */
    public void addRank(int n) {
<span class="nc" id="L164">        setRank(n + getRank());</span>
<span class="nc" id="L165">    }</span>

    /**
     * Add an uplink to this node.
     * 
     * @param newUplink
     *            represents the new uplinks.
     */
    public void addUplink(ClassdiagramNode newUplink) {
<span class="nc" id="L174">        uplinks.add(newUplink);</span>
<span class="nc" id="L175">    }</span>

    /**
     * Calculate the weight of this node. The function distinguishes between
     * note-nodes and standard-nodes, because a note should be positioned to the
     * right of its first related node, if it exists. Therefor the weight is a
     * function of the weight of the related node. For standard-nodes the weight
     * is a function of up-/downlinks, column and uplink factor.
     * 
     * @return The weight of this node.
     */
    public float calculateWeight() {
<span class="nc" id="L187">        weight = 0;</span>
<span class="nc bnc" id="L188" title="All 2 branches missed.">        for (ClassdiagramNode node : uplinks) {</span>
<span class="nc" id="L189">            weight = Math.max(weight, node.getWeight()</span>
                    * UPLINK_FACTOR
<span class="nc" id="L191">                    * (1 + 1 / Math.max(1, node.getColumn() + UPLINK_FACTOR)));</span>
<span class="nc" id="L192">        }</span>
<span class="nc" id="L193">        weight += getSubtreeWeight()</span>
<span class="nc" id="L194">                + (1 / Math.max(1, getColumn() + UPLINK_FACTOR));</span>
<span class="nc" id="L195">        return weight;</span>
    }

    /**
     * The &quot;natural order&quot; for ClassdiagramNodes is defined by the following
     * order.
     * &lt;ul&gt;
     * &lt;li&gt;First standalone, then linked nodes
     * &lt;li&gt;First Packages, then Interfaces/Classes/Notes
     * &lt;li&gt;increasing rank (rownumber)
     * &lt;li&gt;decreasing weight
     * &lt;li&gt;name of model object
     * &lt;li&gt;increasing hashcode (for uniqueness)
     * &lt;/ul&gt;
     * 
     * @see java.lang.Comparable#compareTo(java.lang.Object)
     */
    public int compareTo(Object arg0) {
<span class="nc" id="L213">        ClassdiagramNode node = (ClassdiagramNode) arg0;</span>
<span class="nc" id="L214">        int result = 0;</span>
<span class="nc" id="L215">        result =</span>
<span class="nc" id="L216">                Boolean.valueOf(node.isStandalone()).compareTo(</span>
<span class="nc" id="L217">                        Boolean.valueOf(isStandalone()));</span>
<span class="nc bnc" id="L218" title="All 2 branches missed.">        if (result == 0) {</span>
<span class="nc" id="L219">            result = this.getTypeOrderNumer() - node.getTypeOrderNumer();</span>
        }
<span class="nc bnc" id="L221" title="All 2 branches missed.">        if (result == 0) {</span>
<span class="nc" id="L222">            result = this.getRank() - node.getRank();</span>
        }
<span class="nc bnc" id="L224" title="All 2 branches missed.">        if (result == 0) {</span>
<span class="nc" id="L225">            result = (int) Math.signum(node.getWeight() - this.getWeight());</span>
        }
<span class="nc bnc" id="L227" title="All 2 branches missed.">        if (result == 0) {</span>
<span class="nc" id="L228">            result = String.valueOf(this.getFigure().getOwner()).compareTo(</span>
<span class="nc" id="L229">                    String.valueOf(node.getFigure().getOwner()));</span>
        }
<span class="nc bnc" id="L231" title="All 2 branches missed.">        if (result == 0) {</span>
<span class="nc" id="L232">            result = node.hashCode() - this.hashCode();</span>
        }
        //LOG.debug(result + &quot; node1: &quot; + this + &quot;, node2 &quot; + node);
<span class="nc" id="L235">        return result;</span>
    }

    /**
     * @return The column of this node.
     */
    public int getColumn() {
<span class="nc" id="L242">        return column;</span>
    }


    /**
     * @return The downlinks of this node.
     */
    public List&lt;ClassdiagramNode&gt; getDownNodes() {
<span class="nc" id="L250">        return downlinks;</span>
    }
    
    /**
     * Get the offset which shall be used for edges with this node as parent.
     * 
     * @return The offset
     */
    public int getEdgeOffset() {
<span class="nc" id="L259">        return edgeOffset;</span>
    }

    /**
     * Get the underlying figure of this node.
     * 
     * @return The figure.
     */
    public FigNode getFigure() {
<span class="nc" id="L268">        return figure;</span>
    }

    /**
     * Get the level in the inheritance hierarchy for this node.
     * 
     * @return The level.
     */
    public int getLevel() {
<span class="nc" id="L277">        int result = 0;</span>
<span class="nc bnc" id="L278" title="All 2 branches missed.">        for (ClassdiagramNode node : uplinks) {</span>
<span class="nc bnc" id="L279" title="All 2 branches missed.">            result =</span>
<span class="nc" id="L280">                    (node == this) ? result : Math.max(</span>
<span class="nc" id="L281">                            node.getLevel() + 1, result);</span>
<span class="nc" id="L282">        }</span>
<span class="nc" id="L283">        return result;</span>
    }

    /**
     * Get the location of the underlying figure in the diagram.
     * 
     * @return The location.
     */
    public Point getLocation() {
<span class="nc" id="L292">        return getFigure().getLocation();</span>
    }

    /**
     * Get the current placement hint (X coordinate in the row).
     * 
     * @return The placement hint for this node.
     */
    public int getPlacementHint() {
<span class="nc" id="L301">        return placementHint;</span>
    }

    /**
     * @return The rank for this node.
     */
    public int getRank() {
<span class="nc bnc" id="L308" title="All 2 branches missed.">        return rank == NORANK ? getLevel() : rank;</span>
    }

    /**
     * Return the size of the figure associated with this
     * layout node.
     * 
     * @return The size of the associated figure.
     */
    public Dimension getSize() {
<span class="nc" id="L318">        return getFigure().getSize();</span>
    }

    /**
     * Get the weight of the subtree defined by this node. Impact on weight is
     * decreasing with increasing hierarchical distance
     * 
     * @return The weight of the subtree.
     */
    private float getSubtreeWeight() {

<span class="nc" id="L329">        float w = 1;</span>
<span class="nc bnc" id="L330" title="All 2 branches missed.">        for (ClassdiagramNode node : downlinks) {</span>
<span class="nc" id="L331">            w += node.getSubtreeWeight() / UPLINK_FACTOR;</span>
<span class="nc" id="L332">        }</span>
<span class="nc" id="L333">        return w;</span>
    }

    /**
     * Get the type order number of this node. This number may be used to
     * influence the sort order of ClassdiagramNodes.
     * 
     * @return Type order number.
     */
    public int getTypeOrderNumer() {
<span class="nc" id="L343">        int result = 99;</span>
<span class="nc bnc" id="L344" title="All 2 branches missed.">        if (getFigure() instanceof FigPackage) {</span>
<span class="nc" id="L345">            result = 0;</span>
<span class="nc bnc" id="L346" title="All 2 branches missed.">        } else if (getFigure() instanceof FigInterface) {</span>
<span class="nc" id="L347">            result = 1;</span>
        }
<span class="nc" id="L349">        return result;</span>
    }

    /**
     * Get the uplinks of this node.
     * 
     * @return The uplinks of this node.
     */
    public List&lt;ClassdiagramNode&gt; getUpNodes() {
<span class="nc" id="L358">        return uplinks;</span>
    }
    
    /**
     * Return the weight of this node, which is used for positioning in a row.
     * 
     * @return The weight of this node.
     */
    public float getWeight() {
<span class="nc" id="L367">        return weight;</span>
    }

    /**
     * Check if this node is associated with a note.
     * 
     * @return Result of test.
     */
    public boolean isComment() {
<span class="nc" id="L376">        return (getFigure() instanceof FigComment);</span>
    }

    /**
     * Check if this node is associated with a package.
     * 
     * @return Result of test.
     */
    public boolean isPackage() {
<span class="nc" id="L385">        return (getFigure() instanceof FigPackage);</span>
    }

    /**
     * Test whether this node has no connection to other nodes. Return
     * &lt;code&gt;true&lt;/code&gt; if node has no connections, &lt;code&gt;false&lt;/code&gt;
     * otherwise.
     * 
     * @return Result of test.
     */
    public boolean isStandalone() {
<span class="nc bnc" id="L396" title="All 4 branches missed.">        return uplinks.isEmpty() &amp;&amp; downlinks.isEmpty();</span>
    }

    /**
     * Set the column of this node. A re-calculation of the weight is performed,
     * because the column is an input parameter for the weight.
     * 
     * @param newColumn
     *            The new column.
     */
    public void setColumn(int newColumn) {
<span class="nc" id="L407">        column = newColumn;</span>
<span class="nc" id="L408">        calculateWeight();</span>
<span class="nc" id="L409">    }</span>

    /**
     * Set the offset for edges to this node.
     * 
     * @param newOffset
     *            Offset for edges with this node as one endpoint.
     */
    public void setEdgeOffset(int newOffset) {
<span class="nc" id="L418">        edgeOffset = newOffset;</span>
<span class="nc" id="L419">    }</span>

    /**
     * Set the Fig represented by this node.
     * 
     * @param newFigure
     *            represents the new value of figure.
     */
    public void setFigure(FigNode newFigure) {
<span class="nc" id="L428">        figure = newFigure;</span>
<span class="nc" id="L429">    }</span>

    /**
     * Set the location of the Fig associated with this node.
     * 
     * @param newLocation
     *            represents the new location for this figure.
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public void setLocation(Point newLocation) {
<span class="nc" id="L439">        Point oldLocation = getFigure().getLocation();</span>

<span class="nc" id="L441">        getFigure().setLocation(newLocation);</span>
<span class="nc" id="L442">        int xTrans = newLocation.x - oldLocation.x;</span>
<span class="nc" id="L443">        int yTrans = newLocation.y - oldLocation.y;</span>
<span class="nc bnc" id="L444" title="All 2 branches missed.">        for (Fig fig : (List&lt;Fig&gt;) getFigure().getEnclosedFigs()) {</span>
<span class="nc" id="L445">            fig.translate(xTrans, yTrans);</span>
<span class="nc" id="L446">        }</span>
<span class="nc" id="L447">    }</span>

    /**
     * A placementhint gives an indication where it might be feasible to place
     * this node. It is used by the layouter, and there is no guarantee that it
     * will be used.
     * 
     * @param hint
     *            x coordinate of the desired placement
     */
    public void setPlacementHint(int hint) {
<span class="nc" id="L458">        placementHint = hint;</span>
<span class="nc" id="L459">    }</span>

    /**
     * Set the rank
     * 
     * @param newRank
     *            represents the new value of rank.
     */
    public void setRank(int newRank) {
<span class="nc" id="L468">        rank = newRank;</span>
<span class="nc" id="L469">    }</span>

    /**
     * Set the weight for this node.
     * 
     * @param w
     *            The new weight of this node.
     */
    public void setWeight(float w) {
<span class="nc" id="L478">        weight = w;</span>
<span class="nc" id="L479">    }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>
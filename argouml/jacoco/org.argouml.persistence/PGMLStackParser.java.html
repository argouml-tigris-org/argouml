<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>PGMLStackParser.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">argouml-app</a> &gt; <a href="index.source.html" class="el_package">org.argouml.persistence</a> &gt; <span class="el_source">PGMLStackParser.java</span></div><h1>PGMLStackParser.java</h1><pre class="source lang-java linenums">/* $Id$
 *****************************************************************************
 * Copyright (c) 2009-2012 Contributors - see below
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    Michiel Van Der Wulp
 *    Bob Tarling
 *    Thomas Neustupny
 *****************************************************************************
 *
 * Some portions of this file was previously release using the BSD License:
 */
// Copyright (c) 2005-2009 The Regents of the University of California. All
// Rights Reserved. Permission to use, copy, modify, and distribute this
// software and its documentation without fee, and without a written
// agreement is hereby granted, provided that the above copyright notice
// and this paragraph appear in all copies.  This software program and
// documentation are copyrighted by The Regents of the University of
// California. The software program and documentation are supplied &quot;AS
// IS&quot;, without any accompanying services from The Regents. The Regents
// does not warrant that the operation of the program will be
// uninterrupted or error-free. The end-user understands that the program
// was developed for research purposes and is advised not to rely
// exclusively on the program for any reason.  IN NO EVENT SHALL THE
// UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
// SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS,
// ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF
// THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE. THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY
// WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE
// PROVIDED HEREUNDER IS ON AN &quot;AS IS&quot; BASIS, AND THE UNIVERSITY OF
// CALIFORNIA HAS NO OBLIGATIONS TO PROVIDE MAINTENANCE, SUPPORT,
// UPDATES, ENHANCEMENTS, OR MODIFICATIONS.

package org.argouml.persistence;

import java.awt.Rectangle;
import java.io.InputStream;
import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;
import java.net.URL;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.StringTokenizer;
import java.util.logging.Level;
import java.util.logging.Logger;

import org.argouml.model.Model;
import org.argouml.uml.diagram.ArgoDiagram;
import org.argouml.uml.diagram.DiagramEdgeSettings;
import org.argouml.uml.diagram.DiagramSettings;
import org.argouml.uml.diagram.PathContainer;
import org.argouml.uml.diagram.StereotypeContainer;
import org.argouml.uml.diagram.VisibilityContainer;
import org.argouml.uml.diagram.ui.FigCompartmentBox;
import org.argouml.uml.diagram.ui.FigEdgeModelElement;
import org.argouml.uml.diagram.ui.FigEdgePort;
import org.tigris.gef.base.Diagram;
import org.tigris.gef.persistence.pgml.Container;
import org.tigris.gef.persistence.pgml.FigEdgeHandler;
import org.tigris.gef.persistence.pgml.FigGroupHandler;
import org.tigris.gef.persistence.pgml.HandlerStack;
import org.tigris.gef.presentation.Fig;
import org.tigris.gef.presentation.FigEdge;
import org.tigris.gef.presentation.FigGroup;
import org.tigris.gef.presentation.FigNode;
import org.xml.sax.Attributes;
import org.xml.sax.InputSource;
import org.xml.sax.SAXException;
import org.xml.sax.helpers.DefaultHandler;

// TODO: Move to Diagram subsystem?

/**
 * The PGML Parser.
 * &lt;p&gt;
 *
 * This replaces much of the identically named class from GEF.
 */
class PGMLStackParser extends org.tigris.gef.persistence.pgml.PGMLStackParser {

<span class="fc" id="L90">    private static final Logger LOG =</span>
<span class="fc" id="L91">        Logger.getLogger(PGMLStackParser.class.getName());</span>

<span class="fc" id="L93">    private List&lt;EdgeData&gt; figEdges = new ArrayList&lt;EdgeData&gt;(50);</span>

<span class="fc" id="L95">    private LinkedHashMap&lt;FigEdge, Object&gt; modelElementsByFigEdge =</span>
        new LinkedHashMap&lt;FigEdge, Object&gt;(50);

    private DiagramSettings diagramSettings;

    // TODO: Use stylesheet to convert or wait till we use Fig
    // factories in diagram subsystem.
    // What is the last version that used FigNote?
    private void addTranslations() {
<span class="fc" id="L104">        addTranslation(&quot;org.argouml.uml.diagram.ui.FigNote&quot;,</span>
                &quot;org.argouml.uml.diagram.static_structure.ui.FigComment&quot;);
<span class="fc" id="L106">        addTranslation(&quot;org.argouml.uml.diagram.static_structure.ui.FigNote&quot;,</span>
                &quot;org.argouml.uml.diagram.static_structure.ui.FigComment&quot;);
<span class="fc" id="L108">        addTranslation(&quot;org.argouml.uml.diagram.state.ui.FigState&quot;,</span>
                &quot;org.argouml.uml.diagram.state.ui.FigSimpleState&quot;);
<span class="fc" id="L110">        addTranslation(&quot;org.argouml.uml.diagram.ui.FigCommentPort&quot;,</span>
                &quot;org.argouml.uml.diagram.ui.FigEdgePort&quot;);
<span class="fc" id="L112">        addTranslation(&quot;org.tigris.gef.presentation.FigText&quot;,</span>
                &quot;org.argouml.uml.diagram.ui.ArgoFigText&quot;);
<span class="fc" id="L114">        addTranslation(&quot;org.tigris.gef.presentation.FigLine&quot;,</span>
                &quot;org.argouml.gefext.ArgoFigLine&quot;);
<span class="fc" id="L116">        addTranslation(&quot;org.tigris.gef.presentation.FigPoly&quot;,</span>
                &quot;org.argouml.gefext.ArgoFigPoly&quot;);
<span class="fc" id="L118">        addTranslation(&quot;org.tigris.gef.presentation.FigCircle&quot;,</span>
                &quot;org.argouml.gefext.ArgoFigCircle&quot;);
<span class="fc" id="L120">        addTranslation(&quot;org.tigris.gef.presentation.FigRect&quot;,</span>
                &quot;org.argouml.gefext.ArgoFigRect&quot;);
<span class="fc" id="L122">        addTranslation(&quot;org.tigris.gef.presentation.FigRRect&quot;,</span>
                &quot;org.argouml.gefext.ArgoFigRRect&quot;);
<span class="fc" id="L124">        addTranslation(</span>
                &quot;org.argouml.uml.diagram.deployment.ui.FigMNodeInstance&quot;,
                &quot;org.argouml.uml.diagram.deployment.ui.FigNodeInstance&quot;);
<span class="fc" id="L127">        addTranslation(&quot;org.argouml.uml.diagram.ui.FigRealization&quot;,</span>
                &quot;org.argouml.uml.diagram.ui.FigAbstraction&quot;);
<span class="fc" id="L129">    }</span>

    /**
     * Construct a PGML parser with the given HREF/Object map and default
     * diagram settings.
     *
     * @param modelElementsByUuid map of HREF ids to objects used to associate
     *            Figs with their owning model elements
     * @param defaultSettings default diagram settings to use for newly created
     *            diagram and its contained Figs
     */
    public PGMLStackParser(Map&lt;String, Object&gt; modelElementsByUuid,
            DiagramSettings defaultSettings) {
<span class="fc" id="L142">        super(modelElementsByUuid);</span>
<span class="fc" id="L143">        addTranslations();</span>
        // Create a new diagram wide settings block which is backed by
        // the project-wide defaults that we were passed
<span class="fc" id="L146">        diagramSettings = new DiagramSettings(defaultSettings);</span>
<span class="fc" id="L147">    }</span>

    /*
     * @see org.tigris.gef.persistence.pgml.HandlerFactory#getHandler(
     * HandlerStack, Object, String, String, String, Attributes)
     */
    @Override
    public DefaultHandler getHandler(HandlerStack stack, Object container,
            String uri, String localname, String qname, Attributes attributes)
        throws SAXException {

<span class="fc" id="L158">        String href = attributes.getValue(&quot;href&quot;);</span>
<span class="fc" id="L159">        Object owner = null;</span>

<span class="fc bfc" id="L161" title="All 2 branches covered.">        if (href != null) {</span>
<span class="fc" id="L162">            owner = findOwner(href);</span>
<span class="pc bpc" id="L163" title="1 of 2 branches missed.">            if (owner == null) {</span>
<span class="nc" id="L164">                LOG.log(Level.WARNING, &quot;Found href of &quot; + href</span>
                        + &quot; with no matching element in model&quot;);
<span class="nc" id="L166">                return null;</span>
            }
        }

        // Ignore non-private elements within FigNode groups
<span class="fc bfc" id="L171" title="All 2 branches covered.">        if (container instanceof FigGroupHandler) {</span>
<span class="fc" id="L172">            FigGroup group = ((FigGroupHandler) container).getFigGroup();</span>
<span class="pc bpc" id="L173" title="1 of 4 branches missed.">            if (group instanceof FigNode &amp;&amp; !qname.equals(&quot;private&quot;)) {</span>
<span class="fc" id="L174">                return null;</span>
            }
        }

        // Handle ItemUID in container contents
<span class="pc bpc" id="L179" title="1 of 4 branches missed.">        if (qname.equals(&quot;private&quot;) &amp;&amp; (container instanceof Container)) {</span>
<span class="fc" id="L180">            return new PrivateHandler(this, (Container) container);</span>
        }

<span class="fc" id="L183">        DefaultHandler handler = super.getHandler(stack, container, uri,</span>
                localname, qname, attributes);

<span class="fc bfc" id="L186" title="All 2 branches covered.">        if (handler instanceof FigEdgeHandler) {</span>
<span class="fc" id="L187">            return new org.argouml.persistence.FigEdgeHandler(this,</span>
<span class="fc" id="L188">                    ((FigEdgeHandler) handler).getFigEdge());</span>
        }

<span class="fc" id="L191">        return handler;</span>

    }

    /*
     * @see org.tigris.gef.persistence.pgml.PGMLStackParser#setAttrs(
     * org.tigris.gef.presentation.Fig, org.xml.sax.Attributes)
     */
    @Override
    protected final void setAttrs(Fig f, Attributes attrList)
        throws SAXException {

<span class="fc bfc" id="L203" title="All 2 branches covered.">        if (f instanceof FigGroup) {</span>
<span class="fc" id="L204">            FigGroup group = (FigGroup) f;</span>
<span class="fc" id="L205">            String clsNameBounds = attrList.getValue(&quot;description&quot;);</span>
<span class="pc bpc" id="L206" title="1 of 2 branches missed.">            if (clsNameBounds != null) {</span>
<span class="fc" id="L207">                StringTokenizer st =</span>
                    new StringTokenizer(clsNameBounds, &quot;,;[] &quot;);
                // Discard class name, x y w h
<span class="pc bpc" id="L210" title="1 of 2 branches missed.">                if (st.hasMoreElements()) {</span>
<span class="fc" id="L211">                    st.nextToken();</span>
                }
<span class="pc bpc" id="L213" title="1 of 2 branches missed.">                if (st.hasMoreElements()) {</span>
<span class="fc" id="L214">                    st.nextToken();</span>
                }
<span class="pc bpc" id="L216" title="1 of 2 branches missed.">                if (st.hasMoreElements()) {</span>
<span class="fc" id="L217">                    st.nextToken();</span>
                }
<span class="pc bpc" id="L219" title="1 of 2 branches missed.">                if (st.hasMoreElements()) {</span>
<span class="fc" id="L220">                    st.nextToken();</span>
                }
<span class="pc bpc" id="L222" title="1 of 2 branches missed.">                if (st.hasMoreElements()) {</span>
<span class="fc" id="L223">                    st.nextToken();</span>
                }

<span class="fc" id="L226">                Map&lt;String, String&gt; attributeMap = interpretStyle(st);</span>
<span class="fc" id="L227">                setStyleAttributes(group, attributeMap);</span>
            }
        }

        // TODO: Attempt to move the following code to GEF

<span class="fc" id="L233">        String name = attrList.getValue(&quot;name&quot;);</span>
<span class="pc bpc" id="L234" title="2 of 4 branches missed.">        if (name != null &amp;&amp; !name.equals(&quot;&quot;)) {</span>
<span class="fc" id="L235">            registerFig(f, name);</span>
        }

<span class="fc" id="L238">        setCommonAttrs(f, attrList);</span>

<span class="fc" id="L240">        final String href = attrList.getValue(&quot;href&quot;);</span>
<span class="pc bpc" id="L241" title="1 of 4 branches missed.">        if (href != null &amp;&amp; !href.equals(&quot;&quot;)) {</span>
<span class="fc" id="L242">            Object modelElement = findOwner(href);</span>
<span class="pc bpc" id="L243" title="1 of 2 branches missed.">            if (modelElement == null) {</span>
<span class="nc" id="L244">                LOG.log(Level.SEVERE, &quot;Can't find href of &quot; + href);</span>
<span class="nc" id="L245">                throw new SAXException(&quot;Found href of &quot; + href</span>
                        + &quot; with no matching element in model&quot;);
            }
            // The owner should always have already been set in the constructor
<span class="pc bpc" id="L249" title="1 of 2 branches missed.">            if (f.getOwner() != modelElement) {</span>
                // Assign nodes immediately but edges later. See issue 4310.
<span class="nc bnc" id="L251" title="All 2 branches missed.">                if (f instanceof FigEdge) {</span>
<span class="nc" id="L252">                    modelElementsByFigEdge.put((FigEdge) f, modelElement);</span>
                } else {
<span class="nc" id="L254">                    f.setOwner(modelElement);</span>
                }
            } else {
<span class="fc" id="L257">                LOG.log(Level.FINE,</span>
                        &quot;Ignoring href on {0} as it's already set&quot;,
<span class="fc" id="L259">                        f.getClass().getName());</span>
            }
        }
<span class="fc" id="L262">    }</span>

    /**
     * The StringTokenizer is expected to be positioned at the start of a string
     * of style identifiers in the format name=value;name=value;name=value....
     * Each name value pair is interpreted and the Fig configured accordingly.
     * The value is optional and will default to a value applicable for its
     * name. The current applicable names are operationsVisible and
     * attributesVisible and are used to show or hide the compartments within
     * Class and Interface. The default values are true.
     *
     * @param st The StrinkTokenizer positioned at the first style identifier
     * @return a map of attributes
     */
    private Map&lt;String, String&gt; interpretStyle(StringTokenizer st) {
<span class="fc" id="L277">        Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();</span>
        String name;
        String value;

<span class="fc bfc" id="L281" title="All 2 branches covered.">        while (st.hasMoreElements()) {</span>
<span class="fc" id="L282">            String namevaluepair = st.nextToken();</span>
<span class="fc" id="L283">            int equalsPos = namevaluepair.indexOf('=');</span>
<span class="pc bpc" id="L284" title="1 of 2 branches missed.">            if (equalsPos &lt; 0) {</span>
<span class="nc" id="L285">                name = namevaluepair;</span>
<span class="nc" id="L286">                value = &quot;true&quot;;</span>
            } else {
<span class="fc" id="L288">                name = namevaluepair.substring(0, equalsPos);</span>
<span class="fc" id="L289">                value = namevaluepair.substring(equalsPos + 1);</span>
            }

<span class="fc" id="L292">            map.put(name, value);</span>
<span class="fc" id="L293">        }</span>
<span class="fc" id="L294">        return map;</span>
    }

    /**
     * Set the fig style attributes.
     * &lt;p&gt;
     *
     * TODO: This should move into the render factories as described in issue
     * 859.
     *
     * @param fig the fig to style.
     * @param attributeMap a map of name value pairs
     */
    private void setStyleAttributes(Fig fig, Map&lt;String, String&gt; attributeMap) {

<span class="fc bfc" id="L309" title="All 2 branches covered.">        for (Map.Entry&lt;String, String&gt; entry : attributeMap.entrySet()) {</span>
<span class="fc" id="L310">            final String name = entry.getKey();</span>
<span class="fc" id="L311">            final String value = entry.getValue();</span>

<span class="fc bfc" id="L313" title="All 2 branches covered.">            if (fig instanceof FigCompartmentBox) {</span>
<span class="fc" id="L314">                FigCompartmentBox fcb = (FigCompartmentBox) fig;</span>
<span class="fc bfc" id="L315" title="All 2 branches covered.">                if (&quot;operationsVisible&quot;.equals(name)) {</span>
<span class="fc" id="L316">                    fcb.showCompartment(Model.getMetaTypes().getOperation(),</span>
<span class="fc" id="L317">                            value.equalsIgnoreCase(&quot;true&quot;));</span>
<span class="fc bfc" id="L318" title="All 2 branches covered.">                } else if (&quot;attributesVisible&quot;.equals(name)) {</span>
<span class="fc" id="L319">                    fcb.showCompartment(Model.getMetaTypes().getAttribute(),</span>
<span class="fc" id="L320">                            value.equalsIgnoreCase(&quot;true&quot;));</span>
<span class="pc bpc" id="L321" title="1 of 2 branches missed.">                } else if (&quot;enumerationLiteralsVisible&quot;.equals(name)) {</span>
<span class="nc" id="L322">                    fcb.showCompartment(Model.getMetaTypes()</span>
<span class="nc" id="L323">                            .getEnumerationLiteral(), value</span>
<span class="nc" id="L324">                            .equalsIgnoreCase(&quot;true&quot;));</span>
<span class="fc bfc" id="L325" title="All 2 branches covered.">                } else if (&quot;extensionPointVisible&quot;.equals(name)) {</span>
<span class="fc" id="L326">                    fcb.showCompartment(Model.getMetaTypes()</span>
<span class="fc" id="L327">                            .getExtensionPoint(), value</span>
<span class="fc" id="L328">                            .equalsIgnoreCase(&quot;true&quot;));</span>
                }
            }
<span class="fc bfc" id="L331" title="All 2 branches covered.">            if (&quot;stereotypeVisible&quot;.equals(name)) {</span>
<span class="fc" id="L332">                ((StereotypeContainer) fig).setStereotypeVisible(value</span>
<span class="fc" id="L333">                        .equalsIgnoreCase(&quot;true&quot;));</span>
<span class="fc bfc" id="L334" title="All 2 branches covered.">            } else if (&quot;visibilityVisible&quot;.equals(name)) {</span>
<span class="fc" id="L335">                ((VisibilityContainer) fig).setVisibilityVisible(value</span>
<span class="fc" id="L336">                        .equalsIgnoreCase(&quot;true&quot;));</span>
<span class="fc bfc" id="L337" title="All 2 branches covered.">            } else if (&quot;pathVisible&quot;.equals(name)) {</span>
<span class="fc" id="L338">                ((PathContainer) fig).setPathVisible(value</span>
<span class="fc" id="L339">                        .equalsIgnoreCase(&quot;true&quot;));</span>
            }
<span class="fc" id="L341">        }</span>
<span class="fc" id="L342">    }</span>

    /**
     * Read and parse the input stream to create a new diagram and return it.
     *
     * @param is the input stream
     * @param closeStream true to close the stream when parsing is complete
     * @return the diagram created as a result of the parse
     * @throws SAXException
     */
    public ArgoDiagram readArgoDiagram(InputSource is, boolean closeStream)
        throws SAXException {

<span class="fc" id="L355">        InputStream stream = is.getByteStream();</span>
<span class="pc bpc" id="L356" title="1 of 2 branches missed.">        if (stream == null) {</span>
            try {
                // happens when 'is' comes from a zip file
<span class="nc" id="L359">                URL url = new URL(is.getSystemId());</span>
<span class="nc" id="L360">                stream = url.openStream();</span>
<span class="nc" id="L361">                closeStream = true;</span>
<span class="nc" id="L362">            } catch (Exception e) {</span>
                // continue with null stream, readDiagram(...) will take care of
                // it
<span class="nc" id="L365">            }</span>
        }
<span class="fc" id="L367">        return (ArgoDiagram) readDiagram(stream, closeStream);</span>
    }

    /**
     * Read and parse the input stream to create a new diagram and return it.
     *
     * @param is the input stream
     * @param closeStream true to close the stream when parsing is complete
     * @return the diagram created as a result of the parse
     * @throws SAXException
     */
    public ArgoDiagram readArgoDiagram(InputStream is, boolean closeStream)
        throws SAXException {

<span class="nc" id="L381">        return (ArgoDiagram) readDiagram(is, closeStream);</span>
    }

    @Override
    public Diagram readDiagram(InputStream is, boolean closeStream)
        throws SAXException {

        // TODO: we really want to be able replace the initial content handler
        // which is passed to SAX, but we can't do this without cloning a
        // whole bunch of code because it's private in the super class.

<span class="fc" id="L392">        Diagram d = super.readDiagram(is, closeStream);</span>

<span class="fc" id="L394">        attachEdges(d);</span>

<span class="fc" id="L396">        return d;</span>
    }

    /**
     * This is called when all nodes and edges have been read and placed on the
     * diagram. This method then attaches the edges to the correct node,
     * including the nodes contained within edges allowing edge to edge
     * connections for comment edges, association classes and dependencies.
     *
     * @param d the Diagram
     */
    private void attachEdges(Diagram d) {
<span class="fc bfc" id="L408" title="All 2 branches covered.">        for (EdgeData edgeData : figEdges) {</span>
<span class="fc" id="L409">            final FigEdge edge = edgeData.getFigEdge();</span>

<span class="fc" id="L411">            Object modelElement = modelElementsByFigEdge.get(edge);</span>
<span class="pc bpc" id="L412" title="1 of 2 branches missed.">            if (modelElement != null) {</span>
<span class="nc bnc" id="L413" title="All 2 branches missed.">                if (edge.getOwner() == null) {</span>
<span class="nc" id="L414">                    edge.setOwner(modelElement);</span>
                }
            }
<span class="fc" id="L417">        }</span>

<span class="fc bfc" id="L419" title="All 2 branches covered.">        for (EdgeData edgeData : figEdges) {</span>
<span class="fc" id="L420">            final FigEdge edge = edgeData.getFigEdge();</span>

<span class="fc" id="L422">            Fig sourcePortFig = findFig(edgeData.getSourcePortFigId());</span>
<span class="fc" id="L423">            Fig destPortFig = findFig(edgeData.getDestPortFigId());</span>
<span class="fc" id="L424">            final FigNode sourceFigNode = getFigNode(edgeData</span>
<span class="fc" id="L425">                    .getSourceFigNodeId());</span>
<span class="fc" id="L426">            final FigNode destFigNode = getFigNode(edgeData.getDestFigNodeId());</span>

<span class="fc bfc" id="L428" title="All 2 branches covered.">            if (sourceFigNode instanceof FigEdgePort) {</span>
<span class="fc" id="L429">                sourcePortFig = sourceFigNode;</span>
            }

<span class="fc bfc" id="L432" title="All 2 branches covered.">            if (destFigNode instanceof FigEdgePort) {</span>
<span class="fc" id="L433">                destPortFig = destFigNode;</span>
            }

<span class="pc bpc" id="L436" title="1 of 4 branches missed.">            if (sourcePortFig == null &amp;&amp; sourceFigNode != null) {</span>
<span class="fc" id="L437">                sourcePortFig = getPortFig(sourceFigNode);</span>
            }

<span class="pc bpc" id="L440" title="1 of 4 branches missed.">            if (destPortFig == null &amp;&amp; destFigNode != null) {</span>
<span class="fc" id="L441">                destPortFig = getPortFig(destFigNode);</span>
            }

<span class="pc bpc" id="L444" title="4 of 8 branches missed.">            if (sourcePortFig == null || destPortFig == null</span>
                    || sourceFigNode == null || destFigNode == null) {
<span class="nc" id="L446">                LOG.log(Level.SEVERE,</span>
<span class="nc" id="L447">                        &quot;Can't find nodes for FigEdge: &quot; + edge.getId() + &quot;:&quot;</span>
<span class="nc" id="L448">                        + edge.toString());</span>
<span class="nc" id="L449">                edge.removeFromDiagram();</span>
            } else {
<span class="fc" id="L451">                edge.setSourcePortFig(sourcePortFig);</span>
<span class="fc" id="L452">                edge.setDestPortFig(destPortFig);</span>
<span class="fc" id="L453">                edge.setSourceFigNode(sourceFigNode);</span>
<span class="fc" id="L454">                edge.setDestFigNode(destFigNode);</span>
            }
<span class="fc" id="L456">        }</span>

        // Once all edges are connected do a compute route on each to make
        // sure that annotations and the edge port is positioned correctly
        // Only do this after all edges are connected as compute route
        // requires all edges to be connected to nodes.
        // TODO: It would be nice not to have to do this and restore annotation
        // positions instead.
<span class="fc bfc" id="L464" title="All 2 branches covered.">        for (Object edge : d.getLayer().getContentsEdgesOnly()) {</span>
<span class="fc" id="L465">            FigEdge figEdge = (FigEdge) edge;</span>
<span class="fc" id="L466">            figEdge.computeRouteImpl();</span>
<span class="fc" id="L467">        }</span>
<span class="fc" id="L468">    }</span>

    // TODO: Move to GEF
    /**
     * Store data of a FigEdge together with the id's of nodes to connect to
     *
     * @param figEdge The FigEdge
     * @param sourcePortFigId The id of the source port
     * @param destPortFigId The id of the destination port
     * @param sourceFigNodeId The id of the source node
     * @param destFigNodeId The id of the destination node
     */
    public void addFigEdge(final FigEdge figEdge, final String sourcePortFigId,
            final String destPortFigId, final String sourceFigNodeId,
            final String destFigNodeId) {
<span class="fc" id="L483">        figEdges.add(new EdgeData(figEdge, sourcePortFigId, destPortFigId,</span>
                sourceFigNodeId, destFigNodeId));
<span class="fc" id="L485">    }</span>

    // TODO: Move to GEF
    /**
     * Get the FigNode that the fig id represents.
     *
     * @param figId (In the form Figx.y.z)
     * @return the FigNode with the given id
     * @throws IllegalStateException if the figId supplied is not of a FigNode
     */
    private FigNode getFigNode(String figId) throws IllegalStateException {
<span class="fc bfc" id="L496" title="All 2 branches covered.">        if (figId.contains(&quot;.&quot;)) {</span>
            // If the id does not look like a top-level Fig then we can assume
            // that this is an id of a FigEdgePort inside some FigEdge.
            // So extract the FigEdgePort from the FigEdge and return that as
            // the FigNode.
<span class="fc" id="L501">            figId = figId.substring(0, figId.indexOf('.'));</span>
<span class="fc" id="L502">            FigEdgeModelElement edge = (FigEdgeModelElement) findFig(figId);</span>
<span class="pc bpc" id="L503" title="1 of 2 branches missed.">            if (edge == null) {</span>
<span class="nc" id="L504">                throw new IllegalStateException(&quot;Can't find a FigNode with id &quot;</span>
                        + figId);
            }
<span class="fc" id="L507">            edge.makeEdgePort();</span>
<span class="fc" id="L508">            return edge.getEdgePort();</span>
        } else {
            // If there is no dot then this must be a top level Fig and can be
            // assumed to be a FigNode.
<span class="fc" id="L512">            Fig f = findFig(figId);</span>
<span class="pc bpc" id="L513" title="1 of 2 branches missed.">            if (f instanceof FigNode) {</span>
<span class="fc" id="L514">                return (FigNode) f;</span>
            } else {
<span class="nc" id="L516">                LOG.log(Level.SEVERE,</span>
                        &quot;FigID &quot; + figId + &quot; is not a node, edge ignored&quot;);
<span class="nc" id="L518">                return null;</span>
            }
        }
    }

    // TODO: Move to GEF
    /**
     * Get the Fig from the FigNode that is the port.
     *
     * @param figNode the FigNode
     * @return the Fig that is the port on the given FigNode
     */
    private Fig getPortFig(FigNode figNode) {
<span class="pc bpc" id="L531" title="1 of 2 branches missed.">        if (figNode instanceof FigEdgePort) {</span>
            // TODO: Can we just do this every time, no need for else - Bob
<span class="nc" id="L533">            return figNode;</span>
        } else {
<span class="fc" id="L535">            return (Fig) figNode.getPortFigs().get(0);</span>
        }
    }

    // TODO: Move to GEF

    /**
     * The data from an edge extracted from the PGML before we can guarantee all
     * the nodes have been constructed. This stores the FigEdge and the id's of
     * the nodes to connect to later. If the nodes are not known then the ports
     * are returned instead.
     */
    private class EdgeData {
        private final FigEdge figEdge;

        private final String sourcePortFigId;

        private final String destPortFigId;

        private final String sourceFigNodeId;

        private final String destFigNodeId;

        /**
         * Constructor
         *
         * @param edge The FigEdge
         * @param sourcePortId The id of the source port
         * @param destPortId The id of the destination port
         * @param sourceNodeId The id of the source node
         * @param destNodeId The id of the destination node
         */
        public EdgeData(FigEdge edge, String sourcePortId, String destPortId,
<span class="fc" id="L568">                String sourceNodeId, String destNodeId) {</span>
<span class="pc bpc" id="L569" title="2 of 4 branches missed.">            if (sourcePortId == null || destPortId == null) {</span>
<span class="nc" id="L570">                throw new IllegalArgumentException(</span>
                        &quot;source port and dest port must not be null&quot;
                                + &quot; source = &quot; + sourcePortId + &quot; dest = &quot;
                                + destPortId + &quot; figEdge = &quot; + edge);
            }
<span class="fc" id="L575">            this.figEdge = edge;</span>
<span class="fc" id="L576">            this.sourcePortFigId = sourcePortId;</span>
<span class="fc" id="L577">            this.destPortFigId = destPortId;</span>
<span class="pc bpc" id="L578" title="1 of 2 branches missed.">            this.sourceFigNodeId = sourceNodeId != null ? sourceNodeId</span>
                    : sourcePortId;
<span class="pc bpc" id="L580" title="1 of 2 branches missed.">            this.destFigNodeId = destNodeId != null ? destNodeId : destPortId;</span>
<span class="fc" id="L581">        }</span>

        /**
         * Get the id of the destination FigNode
         *
         * @return the id
         */
        public String getDestFigNodeId() {
<span class="fc" id="L589">            return destFigNodeId;</span>
        }

        /**
         * Get the id of the destination port
         *
         * @return the id
         */
        public String getDestPortFigId() {
<span class="fc" id="L598">            return destPortFigId;</span>
        }

        /**
         * Get the FigEdge
         *
         * @return the FigEdge
         */
        public FigEdge getFigEdge() {
<span class="fc" id="L607">            return figEdge;</span>
        }

        /**
         * Get the id of the source FigNode
         *
         * @return the id
         */
        public String getSourceFigNodeId() {
<span class="fc" id="L616">            return sourceFigNodeId;</span>
        }

        /**
         * Get the id of the source port
         *
         * @return the id
         */
        public String getSourcePortFigId() {
<span class="fc" id="L625">            return sourcePortFigId;</span>
        }
    }

    /**
     * Construct a new instance of the named Fig with the owner represented by
     * the given href and the bounds parsed from the PGML file. We look for
     * constructors of the form Fig(Object owner, Rectangle bounds,
     * DiagramSettings settings) which is typically used for subclasses of
     * FigNodeModelElement, then Fig(Object owner, DiagramSettings settings)
     * which is used for subclasses of FigEdgeModelElement.
     * &lt;p&gt;
     * If we fail to find any of the constructors that we know about, we'll call
     * GEF's version of this method to see if it can find a constructor.
     *
     * @param className fully qualified name of class to instantiate
     * @param href string representing UUID of owning element
     * @param bounds position and size of figure
     * @return
     * @throws SAXException
     * @see org.tigris.gef.persistence.pgml.PGMLStackParser#constructFig(java.lang.String,
     *      java.lang.String, java.awt.Rectangle)
     */
    @Override
    protected Fig constructFig(final String className, final String href,
            final Rectangle bounds, final Attributes attributes)
        throws SAXException {

<span class="fc" id="L653">        final DiagramSettings oldSettings =</span>
<span class="fc" id="L654">            ((ArgoDiagram) getDiagram()).getDiagramSettings();</span>

<span class="fc" id="L656">        Fig f = null;</span>
        try {
<span class="fc" id="L658">            Class figClass = Class.forName(className);</span>

<span class="fc" id="L660">            final Constructor[] constructors = figClass.getConstructors();</span>

            // We are looking first to match with 3 different constructor
            // types. We would not expect a Fig to have any mix of these.
            // Any constructor other than these should be deprecated so we
            // look for these first.
            // Fig(DiagramEdgeSettings, DiagramSettings)
            // Fig(Object, Rectangle, DiagramSettings)
            // Fig(Rectangle, DiagramSettings)
<span class="fc bfc" id="L669" title="All 2 branches covered.">            for (Constructor constructor : constructors) {</span>
<span class="fc" id="L670">                Class[] parameterTypes = constructor.getParameterTypes();</span>
<span class="fc bfc" id="L671" title="All 2 branches covered.">                if (parameterTypes.length == 3</span>
<span class="fc bfc" id="L672" title="All 2 branches covered.">                        &amp;&amp; parameterTypes[0].equals(Object.class)</span>
<span class="pc bpc" id="L673" title="1 of 2 branches missed.">                        &amp;&amp; parameterTypes[1].equals(Rectangle.class)</span>
<span class="pc bpc" id="L674" title="1 of 2 branches missed.">                        &amp;&amp; parameterTypes[2].equals(DiagramSettings.class)) {</span>
                    // FigNodeModelElements should match here
<span class="fc" id="L676">                    final Object parameters[] = new Object[3];</span>
<span class="fc" id="L677">                    final Object owner = getOwner(className, href);</span>
<span class="pc bpc" id="L678" title="1 of 2 branches missed.">                    if (owner == null) {</span>
<span class="nc" id="L679">                        return null;</span>
                    }
<span class="fc" id="L681">                    parameters[0] = owner;</span>
<span class="fc" id="L682">                    parameters[1] = bounds;</span>
<span class="fc" id="L683">                    parameters[2] = oldSettings;</span>

<span class="fc" id="L685">                    constructor.setAccessible(true);</span>
<span class="fc" id="L686">                    f = (Fig) constructor.newInstance(parameters);</span>
<span class="fc bfc" id="L687" title="All 2 branches covered.">                } else if (parameterTypes.length == 2</span>
<span class="fc bfc" id="L688" title="All 2 branches covered.">                        &amp;&amp; parameterTypes[0].equals(DiagramEdgeSettings.class)</span>
<span class="pc bpc" id="L689" title="1 of 2 branches missed.">                        &amp;&amp; parameterTypes[1].equals(DiagramSettings.class)) {</span>
                    // FigEdgeModelElements should match here (they have no
                    // bounds)
<span class="fc" id="L692">                    final Object parameters[] = new Object[2];</span>
<span class="fc" id="L693">                    final Object owner = getOwner(className, href);</span>
<span class="pc bpc" id="L694" title="1 of 2 branches missed.">                    if (owner == null) {</span>
<span class="nc" id="L695">                        return null;</span>
                    }

<span class="fc" id="L698">                    String sourceUuid = attributes.getValue(&quot;sourceConnector&quot;);</span>
<span class="fc" id="L699">                    String destinationUuid = attributes</span>
<span class="fc" id="L700">                            .getValue(&quot;destConnector&quot;);</span>

                    final Object source;
                    final Object destination;
<span class="pc bpc" id="L704" title="3 of 4 branches missed.">                    if (sourceUuid != null &amp;&amp; destinationUuid != null) {</span>
<span class="nc" id="L705">                        source = findOwner(sourceUuid);</span>
<span class="nc" id="L706">                        destination = findOwner(destinationUuid);</span>
                    } else {
<span class="fc" id="L708">                        source = null;</span>
<span class="fc" id="L709">                        destination = null;</span>
                    }

<span class="fc" id="L712">                    DiagramEdgeSettings newSettings = new DiagramEdgeSettings(</span>
                            owner, source, destination);
<span class="fc" id="L714">                    parameters[0] = newSettings;</span>
<span class="fc" id="L715">                    parameters[1] = oldSettings;</span>

<span class="fc" id="L717">                    constructor.setAccessible(true);</span>
<span class="fc" id="L718">                    f = (Fig) constructor.newInstance(parameters);</span>
<span class="fc bfc" id="L719" title="All 2 branches covered.">                } else if (parameterTypes.length == 2</span>
<span class="pc bpc" id="L720" title="1 of 2 branches missed.">                        &amp;&amp; parameterTypes[0].equals(Rectangle.class)</span>
<span class="nc bnc" id="L721" title="All 2 branches missed.">                        &amp;&amp; parameterTypes[1].equals(DiagramSettings.class)) {</span>
                    // A FigNodeModelElement with no owner should match here
                    // TODO: This is a temporary solution due to FigPool
                    // extending
                    // FigNodeModelElement when in fact it should not do so.
<span class="nc" id="L726">                    Object parameters[] = new Object[2];</span>
<span class="nc" id="L727">                    parameters[0] = bounds;</span>
<span class="nc" id="L728">                    parameters[1] = oldSettings;</span>

<span class="nc" id="L730">                    constructor.setAccessible(true);</span>
<span class="nc" id="L731">                    f = (Fig) constructor.newInstance(parameters);</span>
                }
            }
<span class="fc bfc" id="L734" title="All 2 branches covered.">            if (f == null) {</span>
                // If no Fig was created by the code above then we must go
                // look for the old style constructor that should have fallen
                // into disuse by now.
                // Fig(Object, Rectangle, DiagramSettings)
                // All of these constructors should have been deprecated
                // at least and replaced with the new signature. This is
                // here for paranoia only until all Figs have been reviewed.
<span class="fc bfc" id="L742" title="All 2 branches covered.">                for (Constructor constructor : constructors) {</span>
<span class="fc" id="L743">                    Class[] parameterTypes = constructor.getParameterTypes();</span>
<span class="fc bfc" id="L744" title="All 2 branches covered.">                    if (parameterTypes.length == 2</span>
<span class="fc bfc" id="L745" title="All 2 branches covered.">                            &amp;&amp; parameterTypes[0].equals(Object.class)</span>
<span class="pc bpc" id="L746" title="1 of 2 branches missed.">                            &amp;&amp; parameterTypes[1].equals(DiagramSettings.class)) {</span>
<span class="fc" id="L747">                        Object parameters[] = new Object[2];</span>

<span class="fc" id="L749">                        final Object owner = getOwner(className, href);</span>
                        // currently FigEdgeNote can be passed null
//                        if (owner == null) {
//                            return null;
//                        }
<span class="fc" id="L754">                        parameters[0] = owner;</span>
<span class="fc" id="L755">                        parameters[1] = oldSettings;</span>

<span class="fc" id="L757">                        constructor.setAccessible(true);</span>
<span class="fc" id="L758">                        f = (Fig) constructor.newInstance(parameters);</span>
<span class="fc" id="L759">                        LOG.log(Level.WARNING,</span>
                                &quot;Fig created by old style constructor &quot;
<span class="fc" id="L761">                                + f.getClass().getName());</span>
<span class="fc" id="L762">                        break;</span>
                    }
                }
            }
<span class="nc" id="L766">        } catch (ClassNotFoundException e) {</span>
<span class="nc" id="L767">            throw new SAXException(e);</span>
<span class="nc" id="L768">        } catch (IllegalAccessException e) {</span>
<span class="nc" id="L769">            throw new SAXException(e);</span>
<span class="nc" id="L770">        } catch (InstantiationException e) {</span>
<span class="nc" id="L771">            throw new SAXException(e);</span>
<span class="nc" id="L772">        } catch (InvocationTargetException e) {</span>
<span class="nc" id="L773">            throw new SAXException(e);</span>
<span class="fc" id="L774">        }</span>

        // Fall back to GEF's handling if we couldn't find an appropriate
        // constructor
<span class="fc bfc" id="L778" title="All 2 branches covered.">        if (f == null) {</span>
<span class="fc" id="L779">            LOG.log(Level.WARNING,</span>
                    &quot;No ArgoUML constructor found for &quot; + className
                    + &quot; falling back to GEF's default constructors&quot;);
<span class="fc" id="L782">            f = super.constructFig(className, href, bounds, attributes);</span>
        }

<span class="fc" id="L785">        return f;</span>
    }

    /**
     * Given the href extracted from the PGML return the model element with that
     * uuid.
     *
     * @param className Used only for logging should the href not be found
     * @param href The href
     * @return
     */
    private Object getOwner(String className, String id) {
<span class="fc bfc" id="L797" title="All 2 branches covered.">        if (id == null) {</span>
<span class="fc" id="L798">            LOG.log(Level.WARNING,</span>
                    &quot;There is no href attribute provided for a &quot; + className
                    + &quot; so the diagram element is ignored on load&quot;);
<span class="fc" id="L801">            return null;</span>
        }
<span class="fc" id="L803">        final Object owner = findOwner(id);</span>
<span class="pc bpc" id="L804" title="1 of 2 branches missed.">        if (owner == null) {</span>
<span class="nc" id="L805">            LOG.log(Level.WARNING,</span>
                    &quot;The href &quot; + id + &quot; is not found for a &quot; + className
                    + &quot; so the diagram element is ignored on load&quot;);
<span class="nc" id="L808">            return null;</span>
        }
<span class="fc" id="L810">        return owner;</span>
    }

    /**
     * Save the newly created Diagram for use by the parser. We take the
     * opportunity to attach our default diagram settings to it so we'll have
     * them if needed when constructing Figs.
     * &lt;p&gt;
     * Diagrams are created in GEF's PGMLHandler.initDiagram() which is private
     * and can't be overridden. Initialization sequence is:
     * &lt;ul&gt;
     * &lt;li&gt;load diagram class using name in PGML file
     * &lt;li&gt;instantiate using 0-arg constructor
     * &lt;li&gt;invoke this method (setDiagram(&lt;newDiagramInstance))
     * &lt;li&gt;invoke diagram's initialize(Object owner) method
     * &lt;li&gt;diagram.setName()
     * &lt;li&gt;diagram.setScale()
     * &lt;li&gt;diagram.setShowSingleMultiplicity() (?!why does GEF care about
     * multiplicity?!)
     * &lt;/ul&gt;
     *
     * @param diagram the new diagram
     * @see org.tigris.gef.persistence.pgml.PGMLStackParser#setDiagram(org.tigris.gef.base.Diagram)
     */
    @Override
    public void setDiagram(Diagram diagram) {
        // TODO: We could generalize this to initialize more stuff if needed
<span class="fc" id="L837">        ((ArgoDiagram) diagram).setDiagramSettings(getDiagramSettings());</span>
<span class="fc" id="L838">        super.setDiagram(diagram);</span>
<span class="fc" id="L839">    }</span>

    public DiagramSettings getDiagramSettings() {
<span class="fc" id="L842">        return diagramSettings;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>